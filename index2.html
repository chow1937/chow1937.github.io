
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://blog.tonychow.me/theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="https://blog.tonychow.me/theme/pygments/colorful.min.css">


  <link rel="stylesheet" type="text/css" href="https://blog.tonychow.me/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://blog.tonychow.me/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://blog.tonychow.me/theme/font-awesome/css/solid.css">


    <link href="https://blog.tonychow.me/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Tonychow's Blog Atom">



  

    <!-- Chrome, Firefox OS and Opera -->
    <meta name="theme-color" content="#333333">
    <!-- Windows Phone -->
    <meta name="msapplication-navbutton-color" content="#333333">
    <!-- iOS Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Microsoft EDGE -->
    <meta name="msapplication-TileColor" content="#333333">

 

    <meta name="author" content="tonychow" />
    <meta name="description" content="tonychow's Thoughts and Writings" />
  <meta property="og:site_name" content="Tonychow's Blog"/>
  <meta property="og:type" content="blog"/>
  <meta property="og:title" content="Tonychow's Blog"/>
  <meta property="og:description" content="tonychow's Thoughts and Writings"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="https://blog.tonychow.me"/>
  <meta property="og:image" content="/images/avatar.jpg">

  <title>Tonychow's Blog</title>

</head>
<body class="light-theme">
  <aside>
    <div>
      <a href="https://blog.tonychow.me/">
        <img src="/images/avatar.jpg" alt="" title="">
      </a>

      <h1>
        <a href="https://blog.tonychow.me/"></a>
      </h1>

<p>Go/Python backend developer</p>


      <ul class="social">
          <li>
            <a  class="sc-github" href="https://github.com/chow1937" target="_blank">
              <i class="fab fa-github"></i>
            </a>
          </li>
      </ul>
    </div>

  </aside>
  <main>

    <nav>
      <a href="https://blog.tonychow.me/">Home</a>

      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>

      <a href="https://blog.tonychow.me/feeds/all.atom.xml">Atom</a>

    </nav>



<article>
  <header>
    <h2><a href="https://blog.tonychow.me/corepython-reading-notes-how-day6.html#corepython-reading-notes-how-day6">Python 核心编程读书笔记 Day6</a></h2>
    <p>
      Posted on 四 17 七月 2014 in <a href="https://blog.tonychow.me/category/readings.html">readings</a>

          &#8226; Tagged with
              <a href="https://blog.tonychow.me/tag/corepython.html">corepython</a>,              <a href="https://blog.tonychow.me/tag/reading-notes.html">reading-notes</a>,              <a href="https://blog.tonychow.me/tag/python.html">python</a>
        &#8226; 1 min read
    </p>
  </header>
  <div>
      <p>今天阅读了 15-19 章的内容，前面的是 Python 中的关键重要内容，而这之后的几章内容都是 Python 的一些高级内容。所谓高级指的是这些章节描述了一些与 Python 相关的比较高的层面的内容，比如正则表达式，网络编程等等内容，下面继续总结今天的阅读笔记。</p>
<h3>第十五章：正则表达式</h3>
<p>在文本处理和数据处理中，正则表达式提供了一种模式匹配，搜索文本的方式。正则表达式在很多语言中都被支持，而同样 Python 也提供了对正则表达式支持的模块 re。本章的内容就是 Python 的正则表达式模块，下面是要点：</p>
<p>1.正则表达式是一个由含有文本和特别字符组成的字符串，通过正则表达式可以描述想要匹配的内容；</p>
<p>2.<code>re1|re2</code> 表示匹配 re1 或者 re2；</p>
<p>3.<code>.</code> 表示匹配换行符 '\n' 之外的其他任何字符；</p>
<p>4.<code>^</code> 表示匹配字符的开始，在 <code>[]</code> 内表示否定；</p>
<p>5.<code>$</code> 表示匹配字符的结尾；</p>
<!--more-->

<p>6.<code>*</code> 表示匹配前面的正则表达式零次或者多次；</p>
<p>7.<code>+</code> 表示匹配前面的正则表达式一次或者多次；</p>
<p>8.<code>?</code> 表示匹配前面的正则表达式零次或者一次；</p>
<p>9.<code>{N}</code> 表示匹配前面的正则表达式 N 次；</p>
<p>10.<code>{M, N}</code> 表示匹配前面的表达式 M 次到 N 次；</p>
<p>11.<code>[...]</code> 表示匹配里面出现的任意字符，一个；</p>
<p>12.<code>\d</code> 匹配数字；</p>
<p>13.<code>\w</code> 匹配数字及字母；</p>
<p>14.<code>\s</code> 匹配任何空白符；</p>
<p>15.<code>\b</code> 匹配单词的边界(开始)；</p>
<p>16.<code>\D</code>，<code>\W</code>，<code>\S</code>，<code>\B</code> 表示和小写相反，即不匹配；</p>
<p>17.<code>re.search(pattern, string, flags=0)</code> 表示在指定字符串中搜索指定的模式，第一次搜索到则返回匹配结果；</p>
<p>18.<code>re.match(pattern, string, flags=0)</code> 表示对指定字符串从字符串的开始位置尝试匹配指定模式；</p>
<p>19.<code>re.findall(pattern, string[, flags])</code> 表示在指定字符串中搜索所有的匹配结果；</p>
<p>20.<code>re.sub(pattern, repl, string, max=0)</code> 可以对匹配的结果进行替换；</p>
<p>21.Python 的正则表达式是默认贪婪模式的，在利用通配符的时候会尝试匹配最多的字符，可以用 <code>?</code> 来限制；</p>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="https://blog.tonychow.me/corepython-reading-notes-how-day5.html#corepython-reading-notes-how-day5">Python 核心编程读书笔记 Day5</a></h2>
    <p>
      Posted on 三 16 七月 2014 in <a href="https://blog.tonychow.me/category/readings.html">readings</a>

          &#8226; Tagged with
              <a href="https://blog.tonychow.me/tag/corepython.html">corepython</a>,              <a href="https://blog.tonychow.me/tag/reading-notes.html">reading-notes</a>,              <a href="https://blog.tonychow.me/tag/python.html">python</a>
        &#8226; 1 min read
    </p>
  </header>
  <div>
      <p>今天的内容是 Python 中的面向对象和 Python 的执行环境。Python 支持 OOP，虽然很多情况下 Python 直接写函数就可
可以解决大部分的问题，但是 OOP 也是 Python 中的一个重要内容。下面继续总结笔记。</p>
<h3>第十三章：面向对象编程</h3>
<p>本章的内容是 Python 的面向对象编程，具体来说，讲述了 Python 中关于类和 OOP 的具体内容，包括继承，类的方法等
内容，同时也涉及了 Python 中的特殊方法等类的内容。下面是要点：</p>
<p>1.Python 中的实例方法都存在着第一个参数为 self 指示这个实例本身；</p>
<p>2.Python 中的类方法存在着第一个参数为 cls 通常指示这个类本身；</p>
<p>3.Python 中的 <code>__new__(cls,...)</code> 方法才是构建实例的方法，<code>__init__(self,...)</code> 方法是初始化实例的方法；</p>
<p>4.Python 中的子类的构造方法会覆盖父类的构造方法，子类不存在构造方法才会调用父类的构造方法；</p>
<p>5.Python 不支持纯虚函数或者抽象方法；</p>
<p>6.类属性绑定到类的 <code>__dict__</code> 中，实例属性绑定到实例的 <code>__dict__</code> 中；</p>
<p>7.如果实例中不存在一个和类属性同名的实例属性，则通过实例访问到的是类的属性，如果进行修改，则会在实例中保存
一个同名的实例属性存放在实例的 <code>__dict__</code> 中，这个实例属性会屏蔽同名的类属性，注意是屏蔽不是覆盖；</p>
<p>8.<code>__del__</code> 是实例的析构方法，只有在真正需要对该实例进行释放内存的时候才会调用，在 Python 中也就是意味着该
实例的引用计数为 0，进行垃圾回收操作；</p>
<!--more-->

<p>9.类方法和实例方法也是普通的函数，和普通函数不同的是，类方法绑定了类，实例方法绑定了该实例，可以通过类调用
实例方法，但是此时实例方法没有被绑定，需要显式地传入一个实例作为第一个参数；</p>
<p>10.静态方法是在类范围内的普通函数，不是绑定的方法，静态方法也可以通过类继承的方式由子类继承；</p>
<p>11.类的父类保存在 <code>__bases__</code> 类属性中；</p>
<p>12.可以通过 <code>super(Cls, instance).method()</code> 的方式调用父类中的方法；</p>
<p>13.Old-style 类的 MRO 顺序是深度优先地搜索，直到找到，New-style 类的 MRO 顺序是广度优先搜索；</p>
<p>14.可以通过 <code>hasattr</code>，<code>getattr</code>，<code>setattr</code> 和 <code>delattr</code> 等内置函数对类和实例的属性进行操作；</p>
<p>15.Python 中的属性都是公开的，但是以下划线开始的属性会被混淆修改成为另外一个名称，显示出私有的属性；</p>
<p>16.字典会占用大量的内存，New-style 类可以通过 <code>__slots__</code> 属性存放实例属性，节省内存；</p>
<p>17.New-style 的类支持 <code>__getattribute__</code> 方法，实现了这个方法的类在属性被查找的时候都会调用这个方法；</p>
<p>18.描述符是一种将实现了 <code>__get__</code>，<code>__set__</code>，<code>__delete__</code> 特殊方法的类的实例作为另外一个类的类属性的对象
；</p>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="https://blog.tonychow.me/corepython-reading-notes-how-day4.html#corepython-reading-notes-how-day4">Python 核心编程读书笔记 Day4</a></h2>
    <p>
      Posted on 二 15 七月 2014 in <a href="https://blog.tonychow.me/category/readings.html">readings</a>

          &#8226; Tagged with
              <a href="https://blog.tonychow.me/tag/corepython.html">corepython</a>,              <a href="https://blog.tonychow.me/tag/reading-notes.html">reading-notes</a>,              <a href="https://blog.tonychow.me/tag/python.html">python</a>
        &#8226; 1 min read
    </p>
  </header>
  <div>
      <p>今天的主要阅读了 10-12 章的内容，这三章内容主要涉及异常，函数及模块，这几个模块
也是 Python 中比较重要的基本内容，也有相对于其他语言的独特之处，下面继续总结今
天的阅读笔记。</p>
<h3>第十章：错误和异常</h3>
<p>本章关注的内容是异常。异常在其他语言中也有实现，一般来说，异常处理给程序员提供
了一种在错误发生的时候对错误进行处理的方式。与其出现错误的时候，直接终止程序的
执行，不如对错误进行处理之后让程序继续执行。下面是本章要点：</p>
<p>1.错误引发异常的时候会打断正常的程序处理流程；</p>
<p>2.Python 异常的检测可以通过 try 语句进行，通常有 try-excetpt，try-finally模式；</p>
<p>3.try 语句可以带多个 except ，可以处理多种异常，也可以直接多个异常放在一个元组
中；</p>
<p>4.except Exception[, reason]；</p>
<p>5.try-except 同样也支持 else 子句，不发生异常则执行 else 子句的语句；</p>
<p>6.实现了 <code>__enter_</code> 和 <code>__exit__</code> 方法的类可以利用 with 语句；</p>
<p>7.<code>__exit__</code> 具有三个参数，exc_type， exc_value， exc_traceback；</p>
<!--more-->

<h3>第十一章：函数和函数式编程</h3>
<p>函数在 Python 中其实也是一个对象，保存了函数的相关内容，所以在 Python 中，函
数也和普通的对象一样，可以传给一个函数，也可以作为函数的返回值返回，因此也导
至了 Python 支持一部分函数式编程的特性。以下是要点：</p>
<p>1.Python 中的函数即使没有 return 语句，也会默认返回值为 None；</p>
<p>2.Python 中支持默认参数，但是非默认参数需要在默认参数前；</p>
<p>3.Python 中函数支持将参数放进元组或者字典中；</p>
<p>4.<code>func(*args)</code> 的形式是将参数放到元组中；</p>
<p>5.<code>func(**kwargs)</code> 的形式是将参数放到字典中，表示的是应对参数名及其值；</p>
<p>6.Python 支持在函数内部定义函数，并且内部函数可以调用包含函数的局部变量；</p>
<p>7.函数内部是一个局部空间；</p>
<p>8.装饰器函数接受一个函数返回另外一个装饰后的函数；</p>
<p>9.装饰器利用 <code>@</code> 来装饰函数，相当于：<code>foo = deco(foo)</code>；</p>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="https://blog.tonychow.me/corepython-reading-notes-how-day3.html#corepython-reading-notes-how-day3">Python 核心编程读书笔记 Day3</a></h2>
    <p>
      Posted on 日 13 七月 2014 in <a href="https://blog.tonychow.me/category/readings.html">readings</a>

          &#8226; Tagged with
              <a href="https://blog.tonychow.me/tag/corepython.html">corepython</a>,              <a href="https://blog.tonychow.me/tag/reading-notes.html">reading-notes</a>,              <a href="https://blog.tonychow.me/tag/python.html">python</a>
        &#8226; 1 min read
    </p>
  </header>
  <div>
      <p>今天阅读的章节是 8 和 9 章，前面的章节已经介绍了 Python 的基本的数据类型，这两章分别介绍了 Python 的条件
循环语句和文件类型。</p>
<h3>第八章：条件和循环</h3>
<p>这章主要就是介绍 Python 中的条件和循环语句，Python 中的条件语句有 if-else，而循环则有 while 和 for。要点：</p>
<p>1.if 语句有 if-else 和 if-elif-elif-else 模式；</p>
<p>2.Python 中也存在条件表达式，和其他语言的不同，是利用 if 实现的：X if C else Y；</p>
<p>3.Python 中的 while 和其他语言的类似，而 for 循环则不一样，for 循环可以遍历可迭代对象；</p>
<p>4.在遍历迭代器的时候，for 循环会调用迭代器的 next 方法，并且在遇到 StopIteration 异常结束遍历；</p>
<p>5.range(start, stop, step=1) 函数可以生成一个列表；</p>
<p>6.sorted 和 zip 函数返回一个列表，而 reversed 和 enumerate 函数则返回一个迭代器；</p>
<p>7.else 同样可以用在 while 和 for 循环语句中，在循环结束后执行，break 则会跳出这个 else；</p>
<p>8.迭代器对象需要实现 next 和 <code>__iter__</code> 方法；</p>
<p>9.列表解释：[expr for iter_var in iterable]，返回列表；</p>
<p>10.生成器表达式：(expr for iter_var in iterable)；</p>
<!--more-->

<h3>第九章：文件和输入输出</h3>
<p>本章主要关注 Python 中的文件对象及输入和输出方面，下面是要点：</p>
<p>1.文件只是连续的字节序列；</p>
<p>2.可以用 open 或者 file 函数打开或者创建文件，这两个函数类似；</p>
<p>3.文件对象的 readlines 方法将会将该文件所有行都加载到内存中，打开大文件不太友好；</p>
<p>4.xreadlines 是以迭代的方式每次读取文件的一行，不过现在可以直接对文件对象进行迭代达到一样的效果；</p>
<p>5.readline 函数不会去除读取到的行的换行符，writelines 也不会自动添加换行符；</p>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="https://blog.tonychow.me/corepython-reading-notes-how-day2.html#corepython-reading-notes-how-day2">Python 核心编程读书笔记 Day2</a></h2>
    <p>
      Posted on 五 11 七月 2014 in <a href="https://blog.tonychow.me/category/readings.html">readings</a>

          &#8226; Tagged with
              <a href="https://blog.tonychow.me/tag/corepython.html">corepython</a>,              <a href="https://blog.tonychow.me/tag/reading-notes.html">reading-notes</a>,              <a href="https://blog.tonychow.me/tag/python.html">python</a>
        &#8226; 1 min read
    </p>
  </header>
  <div>
      <p>今天主要阅读了 5 - 7 章的内容，继续总结每章的内容及要点。</p>
<h3>第五章：数字</h3>
<p>本章介绍 Python 中的各种数字类型及其运算符和处理数字的内建函数。要点如下：</p>
<p>1.Python 中的数字类型包括整型，长整型，布尔型，双精度浮点型，十进制浮点型和复数，都是不可变类型，对数字类型变量的变
更都会产生一个新的对象；</p>
<p>2.现在的 Python 支持整型自动转换为长整型，不会溢出；</p>
<p>3.Python 中只采用了双精度浮点型，不实现单精度浮点型，如果需要进行银行等系统编写可以考虑使用 Decimal 模块；</p>
<p>4.Python 中不同类型数字运算转换规则：存在复数转换为复数，否则存在浮点数则转换为浮点数，否则存在长整数则转换为长整
数，否则都是普通整数；</p>
<p>5.divmod 函数用于数值计算，返回一个包含商和余数的元组；</p>
<p>6.round 函数对数值进行四舍五入取整，返回一个浮点数；</p>
<p>7.chr 函数将 ASCII 值的数字转换为 ASCII 字符，ord 则相反；</p>
<!--more-->

<h3>第六章：序列：字符串，列表和元组</h3>
<p>这一章关注的是 Python 中的序列类型，这些类型的特点是其成员有序排序，可以通过下标以类似偏移量的方式访问其成员，具体
来说这样的序列类型有三个：字符串，列表和元组。本章详细地介绍了这三个序列类型的操作符内建函数和特性等内容，以下为要
点：</p>
<p>1.序列类型可以使用 <code>in</code> 和 <code>not in</code> 来判定某个元素是否属于一个序列；</p>
<p>2.对于序列使用 <code>+</code> 连接符会导致一个新的序列对象产生；</p>
<p>3.序列类型支持切片操作，可以使用 seq[start:stop:step] 来进行；</p>
<p>4.enumerate 函数接受一个可迭代对象，同样返回一个可迭代的 enumerate 对象，内容为之前对象的 index 和 item；</p>
<p>5.字符串是不可变类型，Python 中没有字符类型，可以用长度为 1 的字符串来表达这个概念；</p>
<p>6.Python 格式化字符：%[(name)][flags][width].[precision]typecode；</p>
<p>7.Python 格式化字符默认右对齐，<code>-</code> 改为左对齐，默认填充空格；</p>
<p>8.<code>r</code> 添加在字符串前表示为原始字符串，不需要对特殊字符进行转义；</p>
<p>9.Unicode 字符串 encode 为 str 字符串，str 字符串 decode 为 Unicode 字符串；</p>
<p>10.列表是可变类型，支持添加插入或者删除元素，并不会产生新的元素；</p>
  </div>
</article>

  <div class="pagination">
    <a class="btn float-left" href="https://blog.tonychow.me/index3.html">
      <i class="fa fa-angle-left"></i> Older Posts
    </a>
    <a class="btn float-right" href="https://blog.tonychow.me/index.html">
      Newer Posts <i class="fa fa-angle-right"></i>
    </a>
  </div>



    <footer>
<p>
  &copy; 2017  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.en_US" target="_blank">Creative Commons Attribution-ShareAlike</a>
</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Tonychow's Blog ",
  "url" : "https://blog.tonychow.me",
  "image": "/images/avatar.jpg",
  "description": "tonychow's Thoughts and Writings"
}
</script>

</body>
</html>