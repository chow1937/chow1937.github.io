
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://blog.tonychow.me/theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="https://blog.tonychow.me/theme/pygments/colorful.min.css">


  <link rel="stylesheet" type="text/css" href="https://blog.tonychow.me/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://blog.tonychow.me/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://blog.tonychow.me/theme/font-awesome/css/solid.css">


    <link href="https://blog.tonychow.me/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Tonychow's Blog Atom">



  

    <!-- Chrome, Firefox OS and Opera -->
    <meta name="theme-color" content="#333333">
    <!-- Windows Phone -->
    <meta name="msapplication-navbutton-color" content="#333333">
    <!-- iOS Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Microsoft EDGE -->
    <meta name="msapplication-TileColor" content="#333333">

 

    <meta name="author" content="tonychow" />
    <meta name="description" content="tonychow's Thoughts and Writings" />
  <meta property="og:site_name" content="Tonychow's Blog"/>
  <meta property="og:type" content="blog"/>
  <meta property="og:title" content="Tonychow's Blog"/>
  <meta property="og:description" content="tonychow's Thoughts and Writings"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="https://blog.tonychow.me"/>
  <meta property="og:image" content="/images/avatar.jpg">

  <title>Tonychow's Blog</title>

</head>
<body class="light-theme">
  <aside>
    <div>
      <a href="https://blog.tonychow.me/">
        <img src="/images/avatar.jpg" alt="" title="">
      </a>

      <h1>
        <a href="https://blog.tonychow.me/"></a>
      </h1>

<p>Go/Python backend developer</p>


      <ul class="social">
          <li>
            <a  class="sc-github" href="https://github.com/chow1937" target="_blank">
              <i class="fab fa-github"></i>
            </a>
          </li>
      </ul>
    </div>

  </aside>
  <main>

    <nav>
      <a href="https://blog.tonychow.me/">Home</a>

      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>

      <a href="https://blog.tonychow.me/feeds/all.atom.xml">Atom</a>

    </nav>



<article>
  <header>
    <h2><a href="https://blog.tonychow.me/corepython-reading-notes-how-day4.html#corepython-reading-notes-how-day4">Python 核心编程读书笔记 Day4</a></h2>
    <p>
      Posted on 二 15 七月 2014 in <a href="https://blog.tonychow.me/category/readings.html">readings</a>

          &#8226; Tagged with
              <a href="https://blog.tonychow.me/tag/corepython.html">corepython</a>,              <a href="https://blog.tonychow.me/tag/reading-notes.html">reading-notes</a>,              <a href="https://blog.tonychow.me/tag/python.html">python</a>
        &#8226; 1 min read
    </p>
  </header>
  <div>
      <p>今天的主要阅读了 10-12 章的内容，这三章内容主要涉及异常，函数及模块，这几个模块
也是 Python 中比较重要的基本内容，也有相对于其他语言的独特之处，下面继续总结今
天的阅读笔记。</p>
<h3>第十章：错误和异常</h3>
<p>本章关注的内容是异常。异常在其他语言中也有实现，一般来说，异常处理给程序员提供
了一种在错误发生的时候对错误进行处理的方式。与其出现错误的时候，直接终止程序的
执行，不如对错误进行处理之后让程序继续执行。下面是本章要点：</p>
<p>1.错误引发异常的时候会打断正常的程序处理流程；</p>
<p>2.Python 异常的检测可以通过 try 语句进行，通常有 try-excetpt，try-finally模式；</p>
<p>3.try 语句可以带多个 except ，可以处理多种异常，也可以直接多个异常放在一个元组
中；</p>
<p>4.except Exception[, reason]；</p>
<p>5.try-except 同样也支持 else 子句，不发生异常则执行 else 子句的语句；</p>
<p>6.实现了 <code>__enter_</code> 和 <code>__exit__</code> 方法的类可以利用 with 语句；</p>
<p>7.<code>__exit__</code> 具有三个参数，exc_type， exc_value， exc_traceback；</p>
<h3>第十一章：函数和函数式编程</h3>
<p>函数在 Python 中其实也是一个对象，保存了函数的相关内容，所以在 Python 中，函
数也和普通的对象一样，可以传给一个函数，也可以作为函数的返回值返回，因此也导
至了 Python 支持一部分函数式编程的特性。以下是要点：</p>
<p>1.Python 中的函数即使没有 return 语句，也会默认返回值为 None；</p>
<p>2.Python 中支持默认参数，但是非默认参数需要在默认参数前；</p>
<p>3.Python 中函数支持将参数放进元组或者字典中；</p>
<p>4.<code>func(*args)</code> 的形式是将参数放到元组中；</p>
<p>5.<code>func(**kwargs)</code> 的形式是将参数放到字典中，表示的是应对参数名及其值；</p>
<p>6.Python 支持在函数内部定义函数，并且内部函数可以调用包含函数的局部变量；</p>
<p>7.函数内部是一个局部空间；</p>
<p>8.装饰器函数接受一个函数返回另外一个装饰后的函数；</p>
<p>9.装饰器利用 <code>@</code> 来装饰函数，相当于：<code>foo = deco(foo)</code>；</p>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="https://blog.tonychow.me/corepython-reading-notes-how-day3.html#corepython-reading-notes-how-day3">Python 核心编程读书笔记 Day3</a></h2>
    <p>
      Posted on 日 13 七月 2014 in <a href="https://blog.tonychow.me/category/readings.html">readings</a>

          &#8226; Tagged with
              <a href="https://blog.tonychow.me/tag/corepython.html">corepython</a>,              <a href="https://blog.tonychow.me/tag/reading-notes.html">reading-notes</a>,              <a href="https://blog.tonychow.me/tag/python.html">python</a>
        &#8226; 1 min read
    </p>
  </header>
  <div>
      <p>今天阅读的章节是 8 和 9 章，前面的章节已经介绍了 Python 的基本的数据类型，这两章分别介绍了 Python 的条件
循环语句和文件类型。</p>
<h3>第八章：条件和循环</h3>
<p>这章主要就是介绍 Python 中的条件和循环语句，Python 中的条件语句有 if-else，而循环则有 while 和 for。要点：</p>
<p>1.if 语句有 if-else 和 if-elif-elif-else 模式；</p>
<p>2.Python 中也存在条件表达式，和其他语言的不同，是利用 if 实现的：X if C else Y；</p>
<p>3.Python 中的 while 和其他语言的类似，而 for 循环则不一样，for 循环可以遍历可迭代对象；</p>
<p>4.在遍历迭代器的时候，for 循环会调用迭代器的 next 方法，并且在遇到 StopIteration 异常结束遍历；</p>
<p>5.range(start, stop, step=1) 函数可以生成一个列表；</p>
<p>6.sorted 和 zip 函数返回一个列表，而 reversed 和 enumerate 函数则返回一个迭代器；</p>
<p>7.else 同样可以用在 while 和 for 循环语句中，在循环结束后执行，break 则会跳出这个 else；</p>
<p>8.迭代器对象需要实现 next 和 <code>__iter__</code> 方法；</p>
<p>9.列表解释：[expr for iter_var in iterable]，返回列表；</p>
<p>10.生成器表达式：(expr for iter_var in iterable)；</p>
<h3>第九章：文件和输入输出</h3>
<p>本章主要关注 Python 中的文件对象及输入和输出方面，下面是要点：</p>
<p>1.文件只是连续的字节序列；</p>
<p>2.可以用 open 或者 file 函数打开或者创建文件，这两个函数类似；</p>
<p>3.文件对象的 readlines 方法将会将该文件所有行都加载到内存中，打开大文件不太友好；</p>
<p>4.xreadlines 是以迭代的方式每次读取文件的一行，不过现在可以直接对文件对象进行迭代达到一样的效果；</p>
<p>5.readline 函数不会去除读取到的行的换行符，writelines 也不会自动添加换行符；</p>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="https://blog.tonychow.me/corepython-reading-notes-how-day2.html#corepython-reading-notes-how-day2">Python 核心编程读书笔记 Day2</a></h2>
    <p>
      Posted on 五 11 七月 2014 in <a href="https://blog.tonychow.me/category/readings.html">readings</a>

          &#8226; Tagged with
              <a href="https://blog.tonychow.me/tag/corepython.html">corepython</a>,              <a href="https://blog.tonychow.me/tag/reading-notes.html">reading-notes</a>,              <a href="https://blog.tonychow.me/tag/python.html">python</a>
        &#8226; 1 min read
    </p>
  </header>
  <div>
      <p>今天主要阅读了 5 - 7 章的内容，继续总结每章的内容及要点。</p>
<h3>第五章：数字</h3>
<p>本章介绍 Python 中的各种数字类型及其运算符和处理数字的内建函数。要点如下：</p>
<p>1.Python 中的数字类型包括整型，长整型，布尔型，双精度浮点型，十进制浮点型和复数，都是不可变类型，对数字类型变量的变
更都会产生一个新的对象；</p>
<p>2.现在的 Python 支持整型自动转换为长整型，不会溢出；</p>
<p>3.Python 中只采用了双精度浮点型，不实现单精度浮点型，如果需要进行银行等系统编写可以考虑使用 Decimal 模块；</p>
<p>4.Python 中不同类型数字运算转换规则：存在复数转换为复数，否则存在浮点数则转换为浮点数，否则存在长整数则转换为长整
数，否则都是普通整数；</p>
<p>5.divmod 函数用于数值计算，返回一个包含商和余数的元组；</p>
<p>6.round 函数对数值进行四舍五入取整，返回一个浮点数；</p>
<p>7.chr 函数将 ASCII 值的数字转换为 ASCII 字符，ord 则相反；</p>
<h3>第六章：序列：字符串，列表和元组</h3>
<p>这一章关注的是 Python 中的序列类型，这些类型的特点是其成员有序排序，可以通过下标以类似偏移量的方式访问其成员，具体
来说这样的序列类型有三个：字符串，列表和元组。本章详细地介绍了这三个序列类型的操作符内建函数和特性等内容，以下为要
点：</p>
<p>1.序列类型可以使用 <code>in</code> 和 <code>not in</code> 来判定某个元素是否属于一个序列；</p>
<p>2.对于序列使用 <code>+</code> 连接符会导致一个新的序列对象产生；</p>
<p>3.序列类型支持切片操作，可以使用 seq[start:stop:step] 来进行；</p>
<p>4.enumerate 函数接受一个可迭代对象，同样返回一个可迭代的 enumerate 对象，内容为之前对象的 index 和 item；</p>
<p>5.字符串是不可变类型，Python 中没有字符类型，可以用长度为 1 的字符串来表达这个概念；</p>
<p>6.Python 格式化字符：%[(name)][flags][width].[precision]typecode；</p>
<p>7.Python 格式化字符默认右对齐，<code>-</code> 改为左对齐，默认填充空格；</p>
<p>8.<code>r</code> 添加在字符串前表示为原始字符串，不需要对特殊字符进行转义；</p>
<p>9.Unicode 字符串 encode 为 str 字符串，str 字符串 decode 为 Unicode 字符串；</p>
<p>10.列表是可变类型，支持添加插入或者删除元素，并不会产生新的元素；</p>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="https://blog.tonychow.me/corepython-reading-notes-how-day1.html#corepython-reading-notes-how-day1">Python 核心编程读书笔记 Day1</a></h2>
    <p>
      Posted on 四 10 七月 2014 in <a href="https://blog.tonychow.me/category/readings.html">readings</a>

          &#8226; Tagged with
              <a href="https://blog.tonychow.me/tag/corepython.html">corepython</a>,              <a href="https://blog.tonychow.me/tag/reading-notes.html">reading-notes</a>,              <a href="https://blog.tonychow.me/tag/python.html">python</a>
        &#8226; 1 min read
    </p>
  </header>
  <div>
      <p>今天主要阅读了 1 - 4 章的内容，下面总结下每章的主要内容和一些要点。</p>
<h3>第一章：Python 核心</h3>
<p>书本的开始只是一些关于 Python 的常识性的内容，包括但不限于起源、各个特性、各个系统的安装
方式还有其他语言(C 语言之外)的实现方式，下面是一些要点：</p>
<p>1.Python 是一门解释性的语言，但是却有个编译成字节码的编译过程，这一点和 Java 是类似的，
因为编译成字节码可以得到性能上的增强；</p>
<p>2.标准的 Python 官方发行的是 C 实现的 Python 版本，被称为 CPython，此外也有其他语言实现
的版本，比如 Java 实现的 Jython，运行在 JVM 上，可以利用到 JVM 的 JIT 技术，并且可以使用
Java 的类库。此外还有 C# 语言实现的 IronPython，可以运行在 .NET 及 Mono 环境上。还有一个
基于 CPython 修改的 Stackless Python ，这个版本对 CPython 解释器进行了大量的修改，实现了
用户级别的微线程。</p>
<h3>第二章：快速入门</h3>
<p>第二章非常简略地过了一遍 Python 的一些特性和语言结构数据类型等，以下是要点：</p>
<p>1.用 "Docstring" 或者 """Docstring""" 在模块，类或者函数起始添加可以实现运行时访问这个文
档字符串；</p>
<p>2.<code>**</code> 是乘方运算符，<code>//</code>是取比商小的最大整数运算；</p>
<p>3.Python 支持复数数字类型，形式类似 4 + 5j；</p>
<p>4.元组和列表都是可以保存任意数量任意类型的 Python 对象的容器对象，并且都是从 0 开始索引
访问元素，元组可以看成只读的列表，两者都支持切片；</p>
<p>5.Python 通过缩进来区分代码块；</p>
<p>6.可以通过列表解释来生成一个列表；</p>
<h3>第三章：Python 基础</h3>
<p>这章的主要内容是基本的 Python 语法，也介绍了标识符，变量和关键字等内容。要点如下：</p>
<p>1.可以通过 <code>\</code> 连接多行的 Python 代码，也可以在含有小括号，中括号和花括号的时候跨行；</p>
<p>2.Python 中，对象是通过引用传递的，将一个对象赋值给一个变量，就是将这个对象的引用赋给
这个变量；</p>
<p>3.Python 中支持增量赋值 <code>+=</code>，但不支持 <code>++</code> 这种自增符；</p>
<p>4.Python 中支持多元赋值，可以同时将多个对象赋给多个变量，这种方式的赋值等号两边其实是两个元组；</p>
<p>5.Python 中下划线对解释器有特殊的意义， <code>_xx</code> 表示模块私有，<code>__xxx__</code> 表示系统定义的</p>
  </div>
  <hr />
</article>
<article>
  <header>
    <h2><a href="https://blog.tonychow.me/python-class-object-source-code.html#python-class-object-source-code">Python 类对象与实例对象源码分析</a></h2>
    <p>
      Posted on 三 02 十月 2013 in <a href="https://blog.tonychow.me/category/python.html">python</a>

          &#8226; Tagged with
              <a href="https://blog.tonychow.me/tag/python.html">python</a>,              <a href="https://blog.tonychow.me/tag/source-reading.html">source-reading</a>
        &#8226; 8 min read
    </p>
  </header>
  <div>
      <h3>一个有趣的现象</h3>
<p>最近在翻 Python 的 Tutorial 的对象一章，随手在 Python 的交互 Shell 中敲了几段代码测试一下，发现了一个有趣的情况。代码如下：</p>
<div class="highlight"><pre><span></span><code>    <span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">TestCls</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>     
    <span class="o">...</span>     <span class="k">def</span> <span class="nf">say_hi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>         <span class="nb">print</span> <span class="s1">&#39;Hi!&#39;</span>
    <span class="o">...</span> 
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">TestCls</span><span class="p">()</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">say_hi</span><span class="p">()</span>
    <span class="n">Hi</span><span class="err">!</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">ins_new_var</span> <span class="o">=</span> <span class="mi">101</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">ins_new_var</span>
    <span class="mi">101</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">TestCls</span><span class="o">.</span><span class="n">ins_new_var</span>
    <span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
      <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="ne">AttributeError</span><span class="p">:</span> <span class="nb">type</span> <span class="nb">object</span> <span class="s1">&#39;TestCls&#39;</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s1">&#39;ins_new_var&#39;</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">TestCls</span><span class="o">.</span><span class="n">new_var</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">TestCls</span><span class="o">.</span><span class="n">new_var</span>
    <span class="mi">100</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">new_var</span>
    <span class="mi">100</span>
<span class="n">这段代码中</span><span class="err">，</span><span class="n">定义了一个类</span> <span class="n">TestCls</span> <span class="err">，</span><span class="n">然后实例化了一个</span> <span class="n">TestCls</span> <span class="n">的对象</span> <span class="n">t</span><span class="err">。</span><span class="n">在</span> <span class="n">Python</span> <span class="n">中</span><span class="err">，</span><span class="n">一切皆对象</span><span class="err">，</span><span class="n">这是老生长谈了</span><span class="err">。</span><span class="n">而</span> <span class="n">Python</span> <span class="n">中的对象还有另外一个特性</span><span class="err">，</span><span class="n">就是可以在创建之后修改这个对象的属性和方法</span><span class="err">。</span><span class="n">如上所示</span><span class="err">，</span><span class="n">我们可以在创建了一个类对象</span> <span class="n">TestCls</span> <span class="n">和一个实例对象</span> <span class="n">t</span> <span class="n">之后</span><span class="err">，</span><span class="n">修改这两个对象</span><span class="err">，</span><span class="n">给它们分别添加了</span> <span class="err">`</span><span class="n">new_var</span><span class="err">`</span> <span class="n">和</span> <span class="err">`</span><span class="n">ins_new_var</span><span class="err">`</span> <span class="n">属性</span><span class="err">。</span><span class="n">从上面的运行结果可以看到</span><span class="err">，</span><span class="n">当我们给实例对象</span> <span class="n">t</span> <span class="n">添加属性</span> <span class="err">`</span><span class="n">ins_new_var</span><span class="err">`</span> <span class="n">之后</span><span class="err">，</span><span class="n">类对象</span> <span class="n">TestCls</span> <span class="n">中访问不了这个属性</span><span class="err">，</span><span class="n">但是对于类对象</span> <span class="n">TestCls</span> <span class="n">添加的新属性</span> <span class="err">`</span><span class="n">new_var</span><span class="err">`</span> <span class="err">，</span><span class="n">这个类对象的实例</span> <span class="n">t</span> <span class="n">却可以访问到</span><span class="err">。</span>
</code></pre></div>

<p>从 Python 代码的这个表现，我们可以推测出一些事情。那就是 Python 中，对一个对象的属性的访问会首先在这个对象的命名空间搜索，如果找不到，那就去搜索这个对象的类的命名空间，直到找到，然后取值，或者抛出没有这个属性的异常。很明显， Python 中一个对象的实例，同时还共享了这个对象的命名空间。如下：</p>
<div class="highlight"><pre><span></span><code>    <span class="o">&gt;&gt;&gt;</span> <span class="nb">dir</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="p">[</span><span class="s1">&#39;__class__&#39;</span><span class="p">,</span> <span class="s1">&#39;__delattr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="s1">&#39;__format__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__getattribute__&#39;</span><span class="p">,</span> <span class="s1">&#39;__hash__&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__new__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__reduce__&#39;</span><span class="p">,</span> <span class="s1">&#39;__reduce_ex__&#39;</span><span class="p">,</span> <span class="s1">&#39;__repr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__setattr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__sizeof__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__str__&#39;</span><span class="p">,</span> <span class="s1">&#39;__subclasshook__&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">,</span> <span class="s1">&#39;ins_new_var&#39;</span><span class="p">,</span> <span class="s1">&#39;new_var&#39;</span><span class="p">,</span>
    <span class="s1">&#39;say_hi&#39;</span><span class="p">]</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="nb">dir</span><span class="p">(</span><span class="n">TestCls</span><span class="p">)</span>
    <span class="p">[</span><span class="s1">&#39;__class__&#39;</span><span class="p">,</span> <span class="s1">&#39;__delattr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="s1">&#39;__format__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__getattribute__&#39;</span><span class="p">,</span> <span class="s1">&#39;__hash__&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__new__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__reduce__&#39;</span><span class="p">,</span> <span class="s1">&#39;__reduce_ex__&#39;</span><span class="p">,</span> <span class="s1">&#39;__repr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__setattr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__sizeof__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__str__&#39;</span><span class="p">,</span> <span class="s1">&#39;__subclasshook__&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">,</span> <span class="s1">&#39;new_var&#39;</span><span class="p">,</span> <span class="s1">&#39;say_hi&#39;</span><span class="p">]</span>
    <span class="o">&gt;&gt;&gt;</span>
</code></pre></div>

<p>可以看到，dir 函数搜索到的实例对象 t 和类对象 TestCls 的基本一致，但是区别在于 t 比 TestCls 多了一个 <code>ins_new_var</code>。</p>
<div class="highlight"><pre><span></span><code>    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="p">{</span><span class="s1">&#39;ins_new_var&#39;</span><span class="p">:</span> <span class="mi">101</span><span class="p">}</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">TestCls</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="n">dict_proxy</span><span class="p">({</span><span class="s1">&#39;__module__&#39;</span><span class="p">:</span> <span class="s1">&#39;__main__&#39;</span><span class="p">,</span> <span class="s1">&#39;say_hi&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">say_hi</span> <span class="n">at</span>
    <span class="mh">0xb771e95c</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">attribute</span> <span class="s1">&#39;__dict__&#39;</span> <span class="n">of</span> <span class="s1">&#39;TestCls&#39;</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="s1">&#39;__weakref__&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">attribute</span> <span class="s1">&#39;__weakref__&#39;</span> <span class="n">of</span> <span class="s1">&#39;TestCls&#39;</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">:</span>
    <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;new_var&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">})</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">new_var</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="p">{</span><span class="s1">&#39;ins_new_var&#39;</span><span class="p">:</span> <span class="mi">101</span><span class="p">,</span> <span class="s1">&#39;new_var&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">}</span>
    <span class="o">&gt;&gt;&gt;</span>
</code></pre></div>

<p>从这里看到，当我们试图对 <code>t.new_var</code> 进行赋值时，t 的 <code>__dict__</code> 增加了一个 <code>new_var</code>。</p>
<p>上面的推测是否正确？也许直接去查看源码会得到答案。在本文中， Python 的源码均指 CPython 源码，版本为 2.7.4。</p>
<p>注1：一般是代码片段在上，分析在下。</p>
<h3>数据结构</h3>
<p>CPython 是 C 写的(很明显)，类对象和实例对象的数据结构都是 struct，定义在 CPython 源码目录的 Include/classobject.h 中：</p>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_bases</span><span class="p">;</span>  <span class="cm">/* A tuple of class objects */</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_dict</span><span class="p">;</span>   <span class="cm">/* A dictionary */</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_name</span><span class="p">;</span>   <span class="cm">/* A string */</span>
    <span class="cm">/* The following three are functions or NULL */</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_getattr</span><span class="p">;</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_setattr</span><span class="p">;</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_delattr</span><span class="p">;</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_weakreflist</span><span class="p">;</span> <span class="cm">/* List of weak references */</span>
<span class="p">}</span> <span class="n">PyClassObject</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">in_class</span><span class="p">;</span>    <span class="cm">/* The class object */</span>
    <span class="n">PyObject</span>      <span class="o">*</span><span class="n">in_dict</span><span class="p">;</span> <span class="cm">/* A dictionary */</span>
    <span class="n">PyObject</span>      <span class="o">*</span><span class="n">in_weakreflist</span><span class="p">;</span> <span class="cm">/* List of weak references */</span>
<span class="p">}</span> <span class="n">PyInstanceObject</span><span class="p">;</span>
</code></pre></div>

<p>这两个结构体并不复杂，除了所有 Python 对象都有的 <code>PyObject_HEAD</code> 宏之外，类对象 PyClassObject 中还有几个属性，分别是： <code>cl_bases</code> ，保存了这个类对象的所有父类(如果有的话)，这个属性是一个元组;<code>cl_dict</code> ，一个字典，保存的是属于这个类对象的属性和方法;<code>cl_name</code> ，保存的是这个类对象的名称，此外还有几个对象 <code>cl_getattr</code>, <code>cl_setattr</code>, <code>cl_delattr</code> ，。而实例对象则有 <code>in_class</code> 表示从哪个类对象实例化而来，还有 <code>in_dict</code> 同样是一个字典对象，保存了这个实例对象的属性和方法。可以看到，一个类的实例对象保存了这个实例对象实例化自哪个类对象。</p>
<p><code>PyObject_HEAD</code> 的相关定义如下：</p>
<div class="highlight"><pre><span></span><code> <span class="cm">/* Define pointers to support a doubly-linked list of all live heap objects. */</span>
<span class="cp">#define _PyObject_HEAD_EXTRA            \</span>
<span class="cp">struct _object *_ob_next;           \</span>
<span class="cp">struct _object *_ob_prev;</span>

<span class="cm">/* PyObject_HEAD defines the initial segment of every PyObject. */</span>
<span class="cp">#define PyObject_HEAD                   \</span>
<span class="cp">_PyObject_HEAD_EXTRA                \</span>
<span class="cp">Py_ssize_t ob_refcnt;               \</span>
<span class="cp">struct _typeobject *ob_type;</span>
</code></pre></div>

<p>可以看到这两个宏定义了 Python 中一个对象的常见属性，包括对象类型 <code>ob_type</code> 和对象的引用计数 <code>ob_refcnt</code>，这是因为 Python 的 GC 方式是引用计数。</p>
<h3>创建函数</h3>
<p>在 Python 中对于类对象 (PyClassObject) 和实例对象 (PyInstanceObject) 的相关函数有很多，在这里我们只是简单分析下创建类对象及实例对象的函数和关于查找属性部分的函数。</p>
<p>注2：这里对这几个函数的代码引用不是完全的。</p>
<h4>实例对象的创建函数</h4>
<p>首先是创建类对象的函数：</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">class_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
</code></pre></div>

<p>创建类对象的函数是 <code>class_new</code> ，参数是类型 type，还有多个参数元组对象 args 和多个关键字参数字典对象 kwds。</p>
<div class="highlight"><pre><span></span><code><span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">bases</span><span class="p">,</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;bases&quot;</span><span class="p">,</span> <span class="s">&quot;dict&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</code></pre></div>

<p>这里新建了几个 PyObject 类型的指针，分别是 name， bases 和 dict ，分别用来保存类对象的名称，继承的父类和属性方法字典。此外还有一个字符串数组 kwlist。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;SOO&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                 <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bases</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dict</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">return</span> <span class="n">PyClass_New</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</code></pre></div>

<p>然后这里是调用 <code>PyArg_ParseTupleAndKeywords</code> 函数，这个函数的主要效果是解析参数 args 和 kwds ，得到创建新的类对象的参数 bases，dict，name，然后调用真正创建一个类对象的函数 <code>PyClass_New</code>。</p>
<div class="highlight"><pre><span></span><code><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyClass_New</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">bases</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
     <span class="cm">/* bases is NULL or tuple of classobjects! */</span>
<span class="p">{</span>
</code></pre></div>

<p><code>PyClass_New</code> 函数的有三个参数，分别是父类们 bases，类的属性方法字典 dict 和 类的名称 name。</p>
<p>接下来很长的一段代码都是对参数的解析及检查参数是否合法，比如 name 必须是一个字符串， dict 必须是一个字典等等，在这里略去。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">docstr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">docstr</span><span class="p">,</span> <span class="n">Py_None</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">modstr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">globals</span> <span class="o">=</span> <span class="n">PyEval_GetGlobals</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">globals</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">modname</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">globals</span><span class="p">,</span> <span class="n">namestr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">modname</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">modstr</span><span class="p">,</span> <span class="n">modname</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>检查参数 dict 中是否有 <code>__doc__</code> 和 <code>__module__</code> 这两个键，如果 <code>__doc__</code> 不存在则设置并将其值设置为 <code>Py_None</code>，如果 <code>__module__</code> 也不存在则获取当前范围的全局变量，从中取得 <code>__module__</code> 所对应的值，赋给这个新类对象的 <code>__module__</code>。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="n">bases</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bases</span> <span class="o">=</span> <span class="n">PyTuple_New</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bases</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">Py_ssize_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyTuple_Check</span><span class="p">(</span><span class="n">bases</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">&quot;PyClass_New: bases must be a tuple&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">PyTuple_Size</span><span class="p">(</span><span class="n">bases</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">PyTuple_GET_ITEM</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyClass_Check</span><span class="p">(</span><span class="n">base</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PyCallable_Check</span><span class="p">(</span>
                <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">PyObject_CallFunctionObjArgs</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                <span class="s">&quot;PyClass_New: base must be a class&quot;</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">bases</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>检查 bases 参数是否为空，如果为空则新建一个值为 0 的元组赋给 bases。不为空，则 bases 应该是一个类对象的元组，依次对这个元组中的类对象进行检测，是否为类对象，如果不是类对象，则检测是否可调用 (callable) ，然后返回相应的错误信息或者一个可调用函数对象的执行结果(可调用)。</p>
<p>最后如果 bases 参数合法，这个参数对象的引用计数加一。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="n">getattrstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">getattrstr</span> <span class="o">=</span> <span class="n">PyString_InternFromString</span><span class="p">(</span><span class="s">&quot;__getattr__&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getattrstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">alloc_error</span><span class="p">;</span>
    <span class="n">setattrstr</span> <span class="o">=</span> <span class="n">PyString_InternFromString</span><span class="p">(</span><span class="s">&quot;__setattr__&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">setattrstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">alloc_error</span><span class="p">;</span>
    <span class="n">delattrstr</span> <span class="o">=</span> <span class="n">PyString_InternFromString</span><span class="p">(</span><span class="s">&quot;__delattr__&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">delattrstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">alloc_error</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>getattrstr</code> ，<code>setattrstr</code> 和 <code>delattrstr</code> 是三个全局的 static PyObject 指针变量，上面这一段分别给它们赋值字符串对象。</p>
<div class="highlight"><pre><span></span><code>    <span class="n">op</span> <span class="o">=</span> <span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">PyClassObject</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyClass_Type</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">alloc_error</span><span class="p">:</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">bases</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>给这个类对象分配内存，这个内存是在堆分配的而且受到 CPython 的 GC 管理的。</p>
<div class="highlight"><pre><span></span><code><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_bases</span> <span class="o">=</span> <span class="n">bases</span><span class="p">;</span>
<span class="n">Py_INCREF</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_dict</span> <span class="o">=</span> <span class="n">dict</span><span class="p">;</span>
<span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_weakreflist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>

<p>将三个参数分别赋给这个新建的类对象 op。</p>
<div class="highlight"><pre><span></span><code>    <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_getattr</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">getattrstr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>
    <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_setattr</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">setattrstr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>
    <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_delattr</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">delattrstr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>
    <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_getattr</span><span class="p">);</span>
    <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_setattr</span><span class="p">);</span>
    <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_delattr</span><span class="p">);</span>
    <span class="n">_PyObject_GC_TRACK</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>然后分别设置这个新类对象的 getattr , setattr 和 delattr 函数，增加这几个函数的引用计数等等，最后返回这个新建的类对象的指针。</p>
<h4>实例对象的创建函数</h4>
<p>实例对象 PyInstanceObject 同样也有个类似的 <code>instance_new</code> 函数：</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_new</span><span class="p">(</span><span class="n">PyTypeObject</span><span class="o">*</span> <span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span><span class="o">*</span> <span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kw</span><span class="p">)</span>
<span class="p">{</span>
</code></pre></div>

<p>参数也和 <code>class_new</code> 类似，三个参数分别为 type ， args 和 kw，</p>
<div class="highlight"><pre><span></span><code><span class="n">PyObject</span> <span class="o">*</span><span class="n">klass</span><span class="p">;</span>
<span class="n">PyObject</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="n">Py_None</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;O!|O:instance&quot;</span><span class="p">,</span>
                      <span class="o">&amp;</span><span class="n">PyClass_Type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">klass</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dict</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>

<p>解析参数，</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="n">dict</span> <span class="o">==</span> <span class="n">Py_None</span><span class="p">)</span>
    <span class="n">dict</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">dict</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
          <span class="s">&quot;instance() second arg must be dictionary or None&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>检查 dict 参数的合法性，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">return</span> <span class="n">PyInstance_NewRaw</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">dict</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>调用 <code>PyInstance_NewRaw</code> 函数，这个才是返回新实例对象的函数：</p>
<div class="highlight"><pre><span></span><code><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyInstance_NewRaw</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">dict</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">;</span>
</code></pre></div>

<p>参数只有所实例化自的类对象和属性方法字典 dict ，</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyClass_Check</span><span class="p">(</span><span class="n">klass</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_BadInternalCall</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">dict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dict</span> <span class="o">=</span> <span class="n">PyDict_New</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">dict</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_BadInternalCall</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>检查参数的合法性，如果 dict 为空 (NULL) 则调用 <code>PyDict_New</code> 参数新建一个字典对象赋给 dict，否则检查 dict 是否是一个 CPython 的字典对象，</p>
<div class="highlight"><pre><span></span><code><span class="n">inst</span> <span class="o">=</span> <span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">PyInstanceObject</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyInstance_Type</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">inst</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>同样是调用 <code>PyObject_GC_New</code> 函数，给这个新建的实例对象分配内存，<code>PyInstance_Type</code> 是一个全局的 PyTypeObject 类型的变量，</p>
<div class="highlight"><pre><span></span><code>    <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_weakreflist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>
    <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyClassObject</span> <span class="o">*</span><span class="p">)</span><span class="n">klass</span><span class="p">;</span>
    <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span> <span class="o">=</span> <span class="n">dict</span><span class="p">;</span>
    <span class="n">_PyObject_GC_TRACK</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">inst</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>最后给新建的实例对象赋值相关属性，然后返回这个新建实例对象的指针。</p>
<p>对于 CPython 的实例对象而言，除了 <code>instance_new</code> 之外，还有另外的一个函数也可以创建一个实例对象：</p>
<div class="highlight"><pre><span></span><code><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyInstance_New</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kw</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">init</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">initstr</span><span class="p">;</span>
</code></pre></div>

<p><code>PyInstance_New</code> 函数也有三个参数，除了第一个是 klass 表示类对象之外，另外两个和 <code>instance_new</code> 函数类似，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">initstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">initstr</span> <span class="o">=</span> <span class="n">PyString_InternFromString</span><span class="p">(</span><span class="s">&quot;__init__&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">initstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">inst</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyInstanceObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">PyInstance_NewRaw</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div>

<p>可以看到在这里调用了 <code>PyInstance_NewRaw</code> 函数创建一个新的实例对象，区别在于 dict 参数为 NULL ，这意味着新建的实例对象没有自己的属性和方法，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">inst</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">init</span> <span class="o">=</span> <span class="n">instance_getattr2</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">initstr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">init</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">arg</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">PyTuple_Check</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">||</span>
                             <span class="n">PyTuple_Size</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">kw</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span> <span class="o">||</span>
                              <span class="n">PyDict_Size</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                       <span class="s">&quot;this constructor takes no arguments&quot;</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>

<p>在新建的实例对象中查找初始化函数 init ，如果不存在 (init 为 NULL) 且发生错误，则返回 NULL ，没有错误则检查 arg 和 kw 这两个参数，设置错误字符串，同样将新建实例对象 inst 置为 NULL，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">else</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">PyEval_CallObjectWithKeywords</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">kw</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">init</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="n">Py_None</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                           <span class="s">&quot;__init__() should return None&quot;</span><span class="p">);</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
                <span class="n">inst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>

<p>init 不为空即意味找到了初始化实例的函数，将初始化函数和参数 arg ，kw 作为参数调用，初始化这个实例对象，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">inst</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>最后返回这个新建的实例对象。</p>
<h3>查找函数与 getattr， setattr 函数</h3>
<p>分析完创建类对象和实例对象的函数之后，我们来分析相关的查找函数，然后还有最重要的 getattr 和 setattr。类对象和实例对象都有自己特有的 getattr 和 setattr 函数，这两类函数正是 Python 中使用 dot 操作符取对象的属性值或者给对象属性赋值所调用的函数。</p>
<h4>类对象的查找函数</h4>
<p>首先是类对象的查找函数 <code>class_lookup</code>，在类对象的创建函数中也曾调用这个函数：</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">class_lookup</span><span class="p">(</span><span class="n">PyClassObject</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyClassObject</span> <span class="o">**</span><span class="n">pclass</span><span class="p">)</span>
<span class="p">{</span>
</code></pre></div>

<p><code>class_lookup</code> 函数有三个参数，分别是类对象指针 cp，查找的属性名称 name 和指向类对象指针的指针变量 pclass，</p>
<div class="highlight"><pre><span></span><code>    <span class="n">Py_ssize_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cl_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">pclass</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>首先查找的是类对象 cp 的 <code>cl_dict</code> 字典，如果找到的值 value 不为空，即已经找到了这个属性的值，则将 pclass 所指向的地址为 cp 类对象的地址，然后返回这个 value，</p>
<div class="highlight"><pre><span></span><code>    <span class="n">n</span> <span class="o">=</span> <span class="n">PyTuple_Size</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cl_bases</span><span class="p">);</span>
</code></pre></div>

<p>否则计算类对象 cp 的父类的个数，也就是 <code>cl_bases</code> 元组的大小，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* XXX What if one of the bases is not a class? */</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span>
            <span class="p">(</span><span class="n">PyClassObject</span> <span class="o">*</span><span class="p">)</span>
            <span class="n">PyTuple_GetItem</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cl_bases</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="n">pclass</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>对 cp 的所有父类递归调用 <code>class_lookup</code> 函数，直到找到这个 name 属性的值，返回到 v 变量，如果 v 非 NULL 则返回 v，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>否则返回 NULL ，表示查找不到这个 name 属性的值。</p>
<h4>类对象的 getattr 函数</h4>
<p>类对象的 getattr 函数实际上调用了 <code>class_lookup</code>函数，如下：</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">class_getattr</span><span class="p">(</span><span class="k">register</span> <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">;</span>
    <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">klass</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">f</span><span class="p">;</span>
</code></pre></div>

<p>有两个参数，分别为类对象指针 op 和 所要获取的属性名称 name,</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyString_Check</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;attribute name must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>首先也是检查参数的合法性，确定 name 为 PyString 对象，以防错误，</p>
<div class="highlight"><pre><span></span><code>    <span class="n">sname</span> <span class="o">=</span> <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">sname</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__dict__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PyEval_GetRestricted</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
               <span class="s">&quot;class.__dict__ not accessible in restricted mode&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_dict</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_dict</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__bases__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_bases</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_bases</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__name__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">Py_None</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">;</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>

<p>这一段首先是检查要获取的是否为特殊属性 <code>__dict__</code>, <code>__bases__</code> 和 <code>__name__</code>，如果是则返回这个类对象的那个特殊属性。之所以作这样的检查是因为接下来就要执行 <code>class_lookup</code> 函数查找，从上面的分析可以知道， <code>class_lookup</code> 函数还会查找其父类，而这些特殊属性每个类对象都有的，所以先做检查可以防止返回错误的属性值，</p>
<div class="highlight"><pre><span></span><code>    <span class="n">v</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">klass</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                     <span class="s">&quot;class %.50s has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                     <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">),</span> <span class="n">sname</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>通过 <code>class_lookup</code> 函数查找这个值，如果找不到则返回 NULL，</p>
<div class="highlight"><pre><span></span><code>    <span class="n">f</span> <span class="o">=</span> <span class="n">TP_DESCR_GET</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>如果找到则尝试获取这个属性值对象的描述符，如果找到(实现了 <code>__get__</code> 方法)，则调用这个描述符方法，因为是类对象，所以第二个参数为 NULL。最后返回值 v 。</p>
<h4>类对象的 setattr 函数</h4>
<p>接下来的是类对象的 setattr 函数：</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">class_setattr</span><span class="p">(</span><span class="n">PyClassObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
</code></pre></div>

<p><code>class_setattr</code> 函数有三个参数，分别是类对象指针 op，属性名称 name 和属性的值 v，</p>
<div class="highlight"><pre><span></span><code>    <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyEval_GetRestricted</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
                   <span class="s">&quot;classes are read-only in restricted mode&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>注意到这里首先检查了此时是否处于受限制模式，如果处于受限制模式，此时类对象是只读的，函数将返回错误码 -1。受限模式下，不受信任的代码的执行将会受到限制。</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyString_Check</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;attribute name must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sname</span> <span class="o">=</span> <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</code></pre></div>

<p>然后是同样检查 name 参数是否为一个 PyString 对象，是则根据这个字符串对象返回一个 C 中的字符串，方便下面的比较。</p>
<p>接下来的一大段代码都是检查上面得到的这个 sname 字符串是否为特殊方法或者特殊的属性，比如 <code>__dict__</code> 或者 <code>__getattr__</code> 等，如果是则调用相关的函数 <code>set_dict</code> 等，一般来说这些特殊属性是不可以修改的，所以会返回错误提示。</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">PyDict_DelItem</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                         <span class="s">&quot;class %.50s has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                         <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">),</span> <span class="n">sname</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>参数 v 为空则将这个保存在类对象结构体 <code>cl_dict</code> 成员中的 name 属性删除掉，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">else</span>
        <span class="k">return</span> <span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>否则，给这个属性 name 赋值 v，保存在类对象的 <code>cl_dict</code> 中。<code>PyDict_SetItem</code> 函数将会检测第一个字典参数中是否具有第二个参数 name 这个键，存在则更新其对应的值为 v，不存在则新建一个键，其值也是 v。</p>
<h4>实例对象的 getattr 函数</h4>
<p>实例对象只有一个简单地搜索属性字典 dict 的函数 <code>_PyInstance_Lookup</code>，这个函数很简单，就是里面做了一点的检查，然后就调用了 <code>PyDict_GetItem</code> 函数从实例对象的 dict 中获取这个值。</p>
<p>而实例对象的 getattr 函数则更多地调用到了<code>class_lookup</code> 函数。CPython 的源码中，关于实例对象的 getattr 和 setattr 函数灰常蛋疼，getattr 函数有三个，分别是 <code>instance_getattr</code> ，<code>instance_getattr1</code> 和 <code>instance_getattr2</code>...而 setattr 函数也有两个，分别是 <code>instance_setattr1</code> 和 <code>instance_setattr</code>。如下：</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_getattr</span><span class="p">(</span><span class="k">register</span> <span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
</code></pre></div>

<p>参数是实例对象指针 inst 和属性名称 name，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">register</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">instance_getattr1</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</code></pre></div>

<p>其实在这里就调用 <code>instance_getattr1</code> 函数了，参数是一致的，如果 <code>instance_getattr1</code> 函数的返回非 NULL，则直接会返回这个结果，下面一段不会执行，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">func</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="o">-&gt;</span><span class="n">cl_getattr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyErr_ExceptionMatches</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">PyErr_Clear</span><span class="p">();</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">PyTuple_Pack</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">PyEval_CallObject</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>

<p>如果 <code>isntance_getattr1</code> 函数的返回值为 NULL 并且实例对象的类的 getattr 函数存在，则调用这个类对像的 getattr 函数，参数是将实例对象指针 inst 和属性名称 name 打包成的元组。</p>
<div class="highlight"><pre><span></span><code>    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>最后返回结果。</p>
<p><code>instance_getattr1</code> 函数如下：</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_getattr1</span><span class="p">(</span><span class="k">register</span> <span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
</code></pre></div>

<p>参数同样是 inst 和 name，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">register</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyString_Check</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;attribute name must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">sname</span> <span class="o">=</span> <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</code></pre></div>

<p>例行检查参数的合法性，合法则将 name 参数转化为 C 的字符串，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">sname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">sname</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__dict__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PyEval_GetRestricted</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
            <span class="s">&quot;instance.__dict__ not accessible in restricted mode&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__class__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">);</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>

<p>同样是检查是否为特殊的属性，主要是以 <code>__</code> 作为开头的属性，这里处理的只有 <code>__dict__</code> 和 <code>__class__</code>。如果是 <code>__dict__</code> ，在受限模式下，会抛出错误表明不可以读取，非受限模式下则返回这个实例对象的属性字典 dict。如果是 <code>__class__</code> ，也是对应地返回实例对象的类。 </p>
<div class="highlight"><pre><span></span><code>    <span class="n">v</span> <span class="o">=</span> <span class="n">instance_getattr2</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                     <span class="s">&quot;%.50s instance has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                     <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">),</span> <span class="n">sname</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>然后调用了 <code>instance_getattr2</code> 函数，如果其返回值为 NULL 则表示不存在这个属性，输出提示，否则返回这个结果 v。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_getattr2</span><span class="p">(</span><span class="k">register</span> <span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
    <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">klass</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">f</span><span class="p">;</span>
</code></pre></div>

<p>同样的， <code>instance_getattr2</code> 函数也是有两个参数 inst 和 name，</p>
<div class="highlight"><pre><span></span><code>    <span class="n">v</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>首先在这个实例对象的 in_dict 中查找这个属性，如果找到则直接返回其值，</p>
<div class="highlight"><pre><span></span><code>    <span class="n">v</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">klass</span><span class="p">);</span>
</code></pre></div>

<p>没有找到则去查找这个实例对象的类对象 <code>in_class</code>，通过上面对 <code>class_lookup</code> 函数的分析我们可以知道，这个查找会一直从实例对象所属的类，其类的父类，父类的父类一直搜索，直到搜索完毕。如果找到了，则返回这个属性的值对象。</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">TP_DESCR_GET</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">inst</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">));</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div>

<p>在这里同样也试图获取这个实例对象对应类型的描述符方法，</p>
<div class="highlight"><pre><span></span><code>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>返回结果 v ，有值或者 NULL。</p>
<p>从对上面三个 getattr 函数的分析可以看到，其实这三个函数各有其功能，比如 <code>instance_getattr1</code> 处理的是特殊属性，而 <code>instance_getattr2</code> 则是对应普通的属性，会一直搜索到其所属的类和其类的父类等等。如果这两个函数都没有结果，则会调用其类的 getattr 函数。</p>
<p>所以这三个函数其实是有其各自的职责的，当然它们三个是可以合并起来成为一个大函数的，但是估计就是不希望看到一个大函数的出现所以才分散为三个函数，这样职责更小更分明。</p>
<h4>实例对象的 setattr 函数</h4>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">instance_setattr</span><span class="p">(</span><span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">;</span>
</code></pre></div>

<p><code>instance_setattr</code> 函数有三个参数，毫无疑问分别是实例对象指针 inst ，属性名称 name 和值 v，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyString_Check</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;attribute name must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">sname</span> <span class="o">=</span> <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</code></pre></div>

<p>同样，惯例检查 name 参数的合法性，合法则转化为 C 的字符串类型变量，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">sname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">sname</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">PyString_Size</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sname</span><span class="p">[</span><span class="n">n</span><span class="mi">-1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">sname</span><span class="p">[</span><span class="n">n</span><span class="mi">-2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div>

<p>判断是否为特殊属性，</p>
<div class="highlight"><pre><span></span><code>            <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__dict__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">PyEval_GetRestricted</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
                 <span class="s">&quot;__dict__ not accessible in restricted mode&quot;</span><span class="p">);</span>
                    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                       <span class="s">&quot;__dict__ must be set to a dictionary&quot;</span><span class="p">);</span>
                    <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">;</span>
                <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
</code></pre></div>

<p>是 <code>__dict__</code> 则检查是否为受限模式，检查传入的 v 参数是否为合法的 PyDict 对象，如果是则将 v 赋值给实例对象的 <code>in_dict</code>。可以注意到，这里用了一个 tmp 变量来保存实例对象之前的 <code>in_dict</code> 变量，然后将其引用计数减一。    </p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__class__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyEval_GetRestricted</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
    <span class="s">&quot;__class__ not accessible in restricted mode&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">PyClass_Check</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
           <span class="s">&quot;__class__ must be set to a class&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyClassObject</span> <span class="o">*</span><span class="p">)</span><span class="n">v</span><span class="p">;</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>如果是 <code>__class__</code> 和上面的操作类似。通过这一段代码，我们可以看到在非受限模式的情况下，一个实例对象的类是可以被动态修改的。</p>
<div class="highlight"><pre><span></span><code>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="o">-&gt;</span><span class="n">cl_delattr</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="o">-&gt;</span><span class="n">cl_setattr</span><span class="p">;</span>
</code></pre></div>

<p>如果参数 v 为 NULL，则表示要将实例对象的这个属性删除掉，试图去获取实例对象所对应的类对象的 delattr 函数。v 不为 NULL 则获取类对象的 setattr 函数，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">func</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instance_setattr1</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div>

<p>如果没有获取到任何的函数，则将会调用 <code>instance_setattr1</code> 函数。</p>
<div class="highlight"><pre><span></span><code>    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">PyTuple_Pack</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">PyTuple_Pack</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">PyEval_CallObject</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div>

<p>无论得到的是类对象的 delattr 还是 setattr 函数，这里将会调用这个函数，区别在于调用 delattr 函数参数元组只有 inst 和 name 而调用 setattr 函数参数则是多了一个参数 v。根据上面对类对象的 setattr 的分析可以知道，如果这个类有 setattr 函数，则将会调用它的 setattr 函数。</p>
<div class="highlight"><pre><span></span><code>    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>执行成功则返回 0。</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">instance_setattr1</span><span class="p">(</span><span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">PyDict_DelItem</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                         <span class="s">&quot;%.50s instance has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                         <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">),</span>
                         <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<p>如果参数 v 为空，则表示删除这个属性，所以将会调用 <code>PyDict_DelItem</code> 函数将这个属性从实例对象的 dict 字典中删除，</p>
<div class="highlight"><pre><span></span><code>    <span class="k">else</span>
        <span class="k">return</span> <span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>否则就直接调用 <code>PyDict_SetItem</code> 函数更新 dict 中的这个值或者添加进 dict 中。</p>
<p>从上面对这两个 setattr 函数的分析，同样可以知道，这两个函数各自有其职责。<code>instance_setattr</code> 主要是对特殊属性进行处理或者是调用其类对象的 setattr 或者 delattr 函数，而 <code>instance_setattr1</code> 函数则是对这个实例对象的 dict 进行 <code>set_item</code> 或者 <code>del_item</code> 操作。</p>
<h3>总结</h3>
<p>其实写到后面已经有点头大了，引用了一大堆源码更像是给源码注释了。但是既然已经写了，那就当给源码注释把它给写完了。</p>
<p>虽然是罗嗦了一堆，但是通过这个分析过程，对于文章开头的那几段代码的情况还是很清晰的：</p>
<ul>
<li>首先，给实例对象 t 添加一个属性 <code>ins_new_var</code> 则将会保存到 t 的 <code>__dict__</code> 中;</li>
<li>而当试图在类对象 TestCls 中取 <code>ins_new_var</code> 的时候，只会去搜索这个类对象的 dict 和其父类的 dict ，这肯定是找不到的，所以返回属性错误;</li>
<li>当给类对象 TestCls 添加一个属性 <code>new_var</code> 的时候，同样，会在 <code>__dict__</code> 中添加一个 <code>new_var</code> 对象;</li>
<li>当访问 t.new_var 的时候，在 t 的命名空间中搜索不到 <code>new_var</code> 的时候，就回去搜索其实例化自的类对象的命名空间，所以，就可以得到这个值了。</li>
</ul>
  </div>
</article>

  <div class="pagination">
    <a class="btn float-left" href="https://blog.tonychow.me/index4.html">
      <i class="fa fa-angle-left"></i> Older Posts
    </a>
    <a class="btn float-right" href="https://blog.tonychow.me/index2.html">
      Newer Posts <i class="fa fa-angle-right"></i>
    </a>
  </div>



    <footer>
<p>
  &copy; 2017  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.en_US" target="_blank">Creative Commons Attribution-ShareAlike</a>
</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Tonychow's Blog ",
  "url" : "https://blog.tonychow.me",
  "image": "/images/avatar.jpg",
  "description": "tonychow's Thoughts and Writings"
}
</script>

</body>
</html>