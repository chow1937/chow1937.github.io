<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <title>Python 类对象与实例对象源码分析</title>
        <link rel="stylesheet" href="http://blog.tonychow.me/theme/css/main.css" />
        <link href="http://blog.tonychow.me/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Tonychow's Blog Atom Feed" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://blog.tonychow.me/">Tonychow's Blog </a></h1>
                <nav><ul>
                    <li><a href="http://blog.tonychow.me/category/linux.html">linux</a></li>
                    <li><a href="http://blog.tonychow.me/category/opencourse.html">opencourse</a></li>
                    <li class="active"><a href="http://blog.tonychow.me/category/python.html">python</a></li>
                    <li><a href="http://blog.tonychow.me/category/readings.html">readings</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="http://blog.tonychow.me/python-class-object-source-code.html" rel="bookmark"
           title="Permalink to Python 类对象与实例对象源码分析">Python 类对象与实例对象源码分析</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2013-10-02T00:00:00+08:00">
                Published: 三 02 十月 2013
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="http://blog.tonychow.me/author/tonychow.html">tonychow</a>
        </address>
<p>In <a href="http://blog.tonychow.me/category/python.html">python</a>.</p>
<p>tags: <a href="http://blog.tonychow.me/tag/python.html">python</a> <a href="http://blog.tonychow.me/tag/source-reading.html">source-reading</a> </p>
</footer><!-- /.post-info -->      <h3>一个有趣的现象</h3>
<p>最近在翻 Python 的 Tutorial 的对象一章，随手在 Python 的交互 Shell 中敲了几段代码测试一下，发现了一个有趣的情况。代码如下：</p>
<div class="highlight"><pre><span></span>    <span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">TestCls</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>     
    <span class="o">...</span>     <span class="k">def</span> <span class="nf">say_hi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>         <span class="k">print</span> <span class="s1">&#39;Hi!&#39;</span>
    <span class="o">...</span> 
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">TestCls</span><span class="p">()</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">say_hi</span><span class="p">()</span>
    <span class="n">Hi</span><span class="err">!</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">ins_new_var</span> <span class="o">=</span> <span class="mi">101</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">ins_new_var</span>
    <span class="mi">101</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">TestCls</span><span class="o">.</span><span class="n">ins_new_var</span>
    <span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
      <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="ne">AttributeError</span><span class="p">:</span> <span class="nb">type</span> <span class="nb">object</span> <span class="s1">&#39;TestCls&#39;</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s1">&#39;ins_new_var&#39;</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">TestCls</span><span class="o">.</span><span class="n">new_var</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">TestCls</span><span class="o">.</span><span class="n">new_var</span>
    <span class="mi">100</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">new_var</span>
    <span class="mi">100</span>
</pre></div>


<!--more-->

<p>这段代码中，定义了一个类 TestCls ，然后实例化了一个 TestCls 的对象 t。在 Python 中，一切皆对象，这是老生长谈了。而 Python 中的对象还有另外一个特性，就是可以在创建之后修改这个对象的属性和方法。如上所示，我们可以在创建了一个类对象 TestCls 和一个实例对象 t 之后，修改这两个对象，给它们分别添加了 <code>new_var</code> 和 <code>ins_new_var</code> 属性。从上面的运行结果可以看到，当我们给实例对象 t 添加属性 <code>ins_new_var</code> 之后，类对象 TestCls 中访问不了这个属性，但是对于类对象 TestCls 添加的新属性 <code>new_var</code> ，这个类对象的实例 t 却可以访问到。</p>
<p>从 Python 代码的这个表现，我们可以推测出一些事情。那就是 Python 中，对一个对象的属性的访问会首先在这个对象的命名空间搜索，如果找不到，那就去搜索这个对象的类的命名空间，直到找到，然后取值，或者抛出没有这个属性的异常。很明显， Python 中一个对象的实例，同时还共享了这个对象的命名空间。如下：</p>
<div class="highlight"><pre><span></span>    <span class="o">&gt;&gt;&gt;</span> <span class="nb">dir</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="p">[</span><span class="s1">&#39;__class__&#39;</span><span class="p">,</span> <span class="s1">&#39;__delattr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="s1">&#39;__format__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__getattribute__&#39;</span><span class="p">,</span> <span class="s1">&#39;__hash__&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__new__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__reduce__&#39;</span><span class="p">,</span> <span class="s1">&#39;__reduce_ex__&#39;</span><span class="p">,</span> <span class="s1">&#39;__repr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__setattr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__sizeof__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__str__&#39;</span><span class="p">,</span> <span class="s1">&#39;__subclasshook__&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">,</span> <span class="s1">&#39;ins_new_var&#39;</span><span class="p">,</span> <span class="s1">&#39;new_var&#39;</span><span class="p">,</span>
    <span class="s1">&#39;say_hi&#39;</span><span class="p">]</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="nb">dir</span><span class="p">(</span><span class="n">TestCls</span><span class="p">)</span>
    <span class="p">[</span><span class="s1">&#39;__class__&#39;</span><span class="p">,</span> <span class="s1">&#39;__delattr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="s1">&#39;__format__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__getattribute__&#39;</span><span class="p">,</span> <span class="s1">&#39;__hash__&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__new__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__reduce__&#39;</span><span class="p">,</span> <span class="s1">&#39;__reduce_ex__&#39;</span><span class="p">,</span> <span class="s1">&#39;__repr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__setattr__&#39;</span><span class="p">,</span> <span class="s1">&#39;__sizeof__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__str__&#39;</span><span class="p">,</span> <span class="s1">&#39;__subclasshook__&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">,</span> <span class="s1">&#39;new_var&#39;</span><span class="p">,</span> <span class="s1">&#39;say_hi&#39;</span><span class="p">]</span>
    <span class="o">&gt;&gt;&gt;</span>
</pre></div>


<p>可以看到，dir 函数搜索到的实例对象 t 和类对象 TestCls 的基本一致，但是区别在于 t 比 TestCls 多了一个 <code>ins_new_var</code>。</p>
<div class="highlight"><pre><span></span>    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="p">{</span><span class="s1">&#39;ins_new_var&#39;</span><span class="p">:</span> <span class="mi">101</span><span class="p">}</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">TestCls</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="n">dict_proxy</span><span class="p">({</span><span class="s1">&#39;__module__&#39;</span><span class="p">:</span> <span class="s1">&#39;__main__&#39;</span><span class="p">,</span> <span class="s1">&#39;say_hi&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">say_hi</span> <span class="n">at</span>
    <span class="mh">0xb771e95c</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">attribute</span> <span class="s1">&#39;__dict__&#39;</span> <span class="n">of</span> <span class="s1">&#39;TestCls&#39;</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="s1">&#39;__weakref__&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">attribute</span> <span class="s1">&#39;__weakref__&#39;</span> <span class="n">of</span> <span class="s1">&#39;TestCls&#39;</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">:</span>
    <span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;new_var&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">})</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">new_var</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="p">{</span><span class="s1">&#39;ins_new_var&#39;</span><span class="p">:</span> <span class="mi">101</span><span class="p">,</span> <span class="s1">&#39;new_var&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">}</span>
    <span class="o">&gt;&gt;&gt;</span>
</pre></div>


<p>从这里看到，当我们试图对 <code>t.new_var</code> 进行赋值时，t 的 <code>__dict__</code> 增加了一个 <code>new_var</code>。</p>
<p>上面的推测是否正确？也许直接去查看源码会得到答案。在本文中， Python 的源码均指 CPython 源码，版本为 2.7.4。</p>
<p>注1：一般是代码片段在上，分析在下。</p>
<h3>数据结构</h3>
<p>CPython 是 C 写的(很明显)，类对象和实例对象的数据结构都是 struct，定义在 CPython 源码目录的 Include/classobject.h 中：</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_bases</span><span class="p">;</span>  <span class="cm">/* A tuple of class objects */</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_dict</span><span class="p">;</span>   <span class="cm">/* A dictionary */</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_name</span><span class="p">;</span>   <span class="cm">/* A string */</span>
    <span class="cm">/* The following three are functions or NULL */</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_getattr</span><span class="p">;</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_setattr</span><span class="p">;</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_delattr</span><span class="p">;</span>
    <span class="n">PyObject</span>    <span class="o">*</span><span class="n">cl_weakreflist</span><span class="p">;</span> <span class="cm">/* List of weak references */</span>
<span class="p">}</span> <span class="n">PyClassObject</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">in_class</span><span class="p">;</span>    <span class="cm">/* The class object */</span>
    <span class="n">PyObject</span>      <span class="o">*</span><span class="n">in_dict</span><span class="p">;</span> <span class="cm">/* A dictionary */</span>
    <span class="n">PyObject</span>      <span class="o">*</span><span class="n">in_weakreflist</span><span class="p">;</span> <span class="cm">/* List of weak references */</span>
<span class="p">}</span> <span class="n">PyInstanceObject</span><span class="p">;</span>
</pre></div>


<p>这两个结构体并不复杂，除了所有 Python 对象都有的 <code>PyObject_HEAD</code> 宏之外，类对象 PyClassObject 中还有几个属性，分别是： <code>cl_bases</code> ，保存了这个类对象的所有父类(如果有的话)，这个属性是一个元组;<code>cl_dict</code> ，一个字典，保存的是属于这个类对象的属性和方法;<code>cl_name</code> ，保存的是这个类对象的名称，此外还有几个对象 <code>cl_getattr</code>, <code>cl_setattr</code>, <code>cl_delattr</code> ，。而实例对象则有 <code>in_class</code> 表示从哪个类对象实例化而来，还有 <code>in_dict</code> 同样是一个字典对象，保存了这个实例对象的属性和方法。可以看到，一个类的实例对象保存了这个实例对象实例化自哪个类对象。</p>
<p><code>PyObject_HEAD</code> 的相关定义如下：</p>
<div class="highlight"><pre><span></span> <span class="cm">/* Define pointers to support a doubly-linked list of all live heap objects. */</span>
<span class="cp">#define _PyObject_HEAD_EXTRA            \</span>
<span class="cp">struct _object *_ob_next;           \</span>
<span class="cp">struct _object *_ob_prev;</span>

<span class="cm">/* PyObject_HEAD defines the initial segment of every PyObject. */</span>
<span class="cp">#define PyObject_HEAD                   \</span>
<span class="cp">_PyObject_HEAD_EXTRA                \</span>
<span class="cp">Py_ssize_t ob_refcnt;               \</span>
<span class="cp">struct _typeobject *ob_type;</span>
</pre></div>


<p>可以看到这两个宏定义了 Python 中一个对象的常见属性，包括对象类型 <code>ob_type</code> 和对象的引用计数 <code>ob_refcnt</code>，这是因为 Python 的 GC 方式是引用计数。</p>
<h3>创建函数</h3>
<p>在 Python 中对于类对象 (PyClassObject) 和实例对象 (PyInstanceObject) 的相关函数有很多，在这里我们只是简单分析下创建类对象及实例对象的函数和关于查找属性部分的函数。</p>
<p>注2：这里对这几个函数的代码引用不是完全的。</p>
<h4>实例对象的创建函数</h4>
<p>首先是创建类对象的函数：</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">class_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>


<p>创建类对象的函数是 <code>class_new</code> ，参数是类型 type，还有多个参数元组对象 args 和多个关键字参数字典对象 kwds。</p>
<div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">bases</span><span class="p">,</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kwlist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;bases&quot;</span><span class="p">,</span> <span class="s">&quot;dict&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</pre></div>


<p>这里新建了几个 PyObject 类型的指针，分别是 name， bases 和 dict ，分别用来保存类对象的名称，继承的父类和属性方法字典。此外还有一个字符串数组 kwlist。</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTupleAndKeywords</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;SOO&quot;</span><span class="p">,</span> <span class="n">kwlist</span><span class="p">,</span>
                                 <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bases</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dict</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">return</span> <span class="nf">PyClass_New</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</pre></div>


<p>然后这里是调用 <code>PyArg_ParseTupleAndKeywords</code> 函数，这个函数的主要效果是解析参数 args 和 kwds ，得到创建新的类对象的参数 bases，dict，name，然后调用真正创建一个类对象的函数 <code>PyClass_New</code>。</p>
<div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyClass_New</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">bases</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
     <span class="cm">/* bases is NULL or tuple of classobjects! */</span>
<span class="p">{</span>
</pre></div>


<p><code>PyClass_New</code> 函数的有三个参数，分别是父类们 bases，类的属性方法字典 dict 和 类的名称 name。</p>
<p>接下来很长的一段代码都是对参数的解析及检查参数是否合法，比如 name 必须是一个字符串， dict 必须是一个字典等等，在这里略去。</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">docstr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">docstr</span><span class="p">,</span> <span class="n">Py_None</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">modstr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">globals</span> <span class="o">=</span> <span class="n">PyEval_GetGlobals</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">globals</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">modname</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">globals</span><span class="p">,</span> <span class="n">namestr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">modname</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">modstr</span><span class="p">,</span> <span class="n">modname</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>检查参数 dict 中是否有 <code>__doc__</code> 和 <code>__module__</code> 这两个键，如果 <code>__doc__</code> 不存在则设置并将其值设置为 <code>Py_None</code>，如果 <code>__module__</code> 也不存在则获取当前范围的全局变量，从中取得 <code>__module__</code> 所对应的值，赋给这个新类对象的 <code>__module__</code>。</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">bases</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bases</span> <span class="o">=</span> <span class="n">PyTuple_New</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bases</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">Py_ssize_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyTuple_Check</span><span class="p">(</span><span class="n">bases</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                        <span class="s">&quot;PyClass_New: bases must be a tuple&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">PyTuple_Size</span><span class="p">(</span><span class="n">bases</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">PyTuple_GET_ITEM</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyClass_Check</span><span class="p">(</span><span class="n">base</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PyCallable_Check</span><span class="p">(</span>
                <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">PyObject_CallFunctionObjArgs</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                <span class="s">&quot;PyClass_New: base must be a class&quot;</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">bases</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>检查 bases 参数是否为空，如果为空则新建一个值为 0 的元组赋给 bases。不为空，则 bases 应该是一个类对象的元组，依次对这个元组中的类对象进行检测，是否为类对象，如果不是类对象，则检测是否可调用 (callable) ，然后返回相应的错误信息或者一个可调用函数对象的执行结果(可调用)。</p>
<p>最后如果 bases 参数合法，这个参数对象的引用计数加一。</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">getattrstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">getattrstr</span> <span class="o">=</span> <span class="n">PyString_InternFromString</span><span class="p">(</span><span class="s">&quot;__getattr__&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getattrstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">alloc_error</span><span class="p">;</span>
    <span class="n">setattrstr</span> <span class="o">=</span> <span class="n">PyString_InternFromString</span><span class="p">(</span><span class="s">&quot;__setattr__&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">setattrstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">alloc_error</span><span class="p">;</span>
    <span class="n">delattrstr</span> <span class="o">=</span> <span class="n">PyString_InternFromString</span><span class="p">(</span><span class="s">&quot;__delattr__&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">delattrstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">alloc_error</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><code>getattrstr</code> ，<code>setattrstr</code> 和 <code>delattrstr</code> 是三个全局的 static PyObject 指针变量，上面这一段分别给它们赋值字符串对象。</p>
<div class="highlight"><pre><span></span>    <span class="n">op</span> <span class="o">=</span> <span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">PyClassObject</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyClass_Type</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">alloc_error</span><span class="p">:</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">bases</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>给这个类对象分配内存，这个内存是在堆分配的而且受到 CPython 的 GC 管理的。</p>
<div class="highlight"><pre><span></span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_bases</span> <span class="o">=</span> <span class="n">bases</span><span class="p">;</span>
<span class="n">Py_INCREF</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_dict</span> <span class="o">=</span> <span class="n">dict</span><span class="p">;</span>
<span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_weakreflist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>


<p>将三个参数分别赋给这个新建的类对象 op。</p>
<div class="highlight"><pre><span></span>    <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_getattr</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">getattrstr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>
    <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_setattr</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">setattrstr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>
    <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_delattr</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">delattrstr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">);</span>
    <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_getattr</span><span class="p">);</span>
    <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_setattr</span><span class="p">);</span>
    <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_delattr</span><span class="p">);</span>
    <span class="n">_PyObject_GC_TRACK</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>然后分别设置这个新类对象的 getattr , setattr 和 delattr 函数，增加这几个函数的引用计数等等，最后返回这个新建的类对象的指针。</p>
<h4>实例对象的创建函数</h4>
<p>实例对象 PyInstanceObject 同样也有个类似的 <code>instance_new</code> 函数：</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_new</span><span class="p">(</span><span class="n">PyTypeObject</span><span class="o">*</span> <span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span><span class="o">*</span> <span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kw</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>


<p>参数也和 <code>class_new</code> 类似，三个参数分别为 type ， args 和 kw，</p>
<div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">klass</span><span class="p">;</span>
<span class="n">PyObject</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="n">Py_None</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;O!|O:instance&quot;</span><span class="p">,</span>
                      <span class="o">&amp;</span><span class="n">PyClass_Type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">klass</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dict</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>


<p>解析参数，</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">dict</span> <span class="o">==</span> <span class="n">Py_None</span><span class="p">)</span>
    <span class="n">dict</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">dict</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
          <span class="s">&quot;instance() second arg must be dictionary or None&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>检查 dict 参数的合法性，</p>
<div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="nf">PyInstance_NewRaw</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">dict</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>调用 <code>PyInstance_NewRaw</code> 函数，这个才是返回新实例对象的函数：</p>
<div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyInstance_NewRaw</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">dict</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">;</span>
</pre></div>


<p>参数只有所实例化自的类对象和属性方法字典 dict ，</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyClass_Check</span><span class="p">(</span><span class="n">klass</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">PyErr_BadInternalCall</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">dict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dict</span> <span class="o">=</span> <span class="n">PyDict_New</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">dict</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_BadInternalCall</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>检查参数的合法性，如果 dict 为空 (NULL) 则调用 <code>PyDict_New</code> 参数新建一个字典对象赋给 dict，否则检查 dict 是否是一个 CPython 的字典对象，</p>
<div class="highlight"><pre><span></span><span class="n">inst</span> <span class="o">=</span> <span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">PyInstanceObject</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyInstance_Type</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">inst</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>同样是调用 <code>PyObject_GC_New</code> 函数，给这个新建的实例对象分配内存，<code>PyInstance_Type</code> 是一个全局的 PyTypeObject 类型的变量，</p>
<div class="highlight"><pre><span></span>    <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_weakreflist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>
    <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyClassObject</span> <span class="o">*</span><span class="p">)</span><span class="n">klass</span><span class="p">;</span>
    <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span> <span class="o">=</span> <span class="n">dict</span><span class="p">;</span>
    <span class="n">_PyObject_GC_TRACK</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">inst</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>最后给新建的实例对象赋值相关属性，然后返回这个新建实例对象的指针。</p>
<p>对于 CPython 的实例对象而言，除了 <code>instance_new</code> 之外，还有另外的一个函数也可以创建一个实例对象：</p>
<div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyInstance_New</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">klass</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kw</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">init</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">initstr</span><span class="p">;</span>
</pre></div>


<p><code>PyInstance_New</code> 函数也有三个参数，除了第一个是 klass 表示类对象之外，另外两个和 <code>instance_new</code> 函数类似，</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">initstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">initstr</span> <span class="o">=</span> <span class="n">PyString_InternFromString</span><span class="p">(</span><span class="s">&quot;__init__&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">initstr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">inst</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyInstanceObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">PyInstance_NewRaw</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>


<p>可以看到在这里调用了 <code>PyInstance_NewRaw</code> 函数创建一个新的实例对象，区别在于 dict 参数为 NULL ，这意味着新建的实例对象没有自己的属性和方法，</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">inst</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">init</span> <span class="o">=</span> <span class="n">instance_getattr2</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">initstr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">init</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">arg</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">PyTuple_Check</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">||</span>
                             <span class="n">PyTuple_Size</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="o">||</span> <span class="p">(</span><span class="n">kw</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span> <span class="o">||</span>
                              <span class="n">PyDict_Size</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                       <span class="s">&quot;this constructor takes no arguments&quot;</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>在新建的实例对象中查找初始化函数 init ，如果不存在 (init 为 NULL) 且发生错误，则返回 NULL ，没有错误则检查 arg 和 kw 这两个参数，设置错误字符串，同样将新建实例对象 inst 置为 NULL，</p>
<div class="highlight"><pre><span></span>    <span class="k">else</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">PyEval_CallObjectWithKeywords</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">kw</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">init</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="n">Py_None</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                           <span class="s">&quot;__init__() should return None&quot;</span><span class="p">);</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
                <span class="n">inst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>init 不为空即意味找到了初始化实例的函数，将初始化函数和参数 arg ，kw 作为参数调用，初始化这个实例对象，</p>
<div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">inst</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>最后返回这个新建的实例对象。</p>
<h3>查找函数与 getattr， setattr 函数</h3>
<p>分析完创建类对象和实例对象的函数之后，我们来分析相关的查找函数，然后还有最重要的 getattr 和 setattr。类对象和实例对象都有自己特有的 getattr 和 setattr 函数，这两类函数正是 Python 中使用 dot 操作符取对象的属性值或者给对象属性赋值所调用的函数。</p>
<h4>类对象的查找函数</h4>
<p>首先是类对象的查找函数 <code>class_lookup</code>，在类对象的创建函数中也曾调用这个函数：</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">class_lookup</span><span class="p">(</span><span class="n">PyClassObject</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyClassObject</span> <span class="o">**</span><span class="n">pclass</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>


<p><code>class_lookup</code> 函数有三个参数，分别是类对象指针 cp，查找的属性名称 name 和指向类对象指针的指针变量 pclass，</p>
<div class="highlight"><pre><span></span>    <span class="n">Py_ssize_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cl_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">pclass</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>首先查找的是类对象 cp 的 <code>cl_dict</code> 字典，如果找到的值 value 不为空，即已经找到了这个属性的值，则将 pclass 所指向的地址为 cp 类对象的地址，然后返回这个 value，</p>
<div class="highlight"><pre><span></span>    <span class="n">n</span> <span class="o">=</span> <span class="n">PyTuple_Size</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cl_bases</span><span class="p">);</span>
</pre></div>


<p>否则计算类对象 cp 的父类的个数，也就是 <code>cl_bases</code> 元组的大小，</p>
<div class="highlight"><pre><span></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* XXX What if one of the bases is not a class? */</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span>
            <span class="p">(</span><span class="n">PyClassObject</span> <span class="o">*</span><span class="p">)</span>
            <span class="n">PyTuple_GetItem</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cl_bases</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="n">pclass</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>对 cp 的所有父类递归调用 <code>class_lookup</code> 函数，直到找到这个 name 属性的值，返回到 v 变量，如果 v 非 NULL 则返回 v，</p>
<div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>否则返回 NULL ，表示查找不到这个 name 属性的值。</p>
<h4>类对象的 getattr 函数</h4>
<p>类对象的 getattr 函数实际上调用了 <code>class_lookup</code>函数，如下：</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">class_getattr</span><span class="p">(</span><span class="k">register</span> <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">;</span>
    <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">klass</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">f</span><span class="p">;</span>
</pre></div>


<p>有两个参数，分别为类对象指针 op 和 所要获取的属性名称 name,</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyString_Check</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;attribute name must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>首先也是检查参数的合法性，确定 name 为 PyString 对象，以防错误，</p>
<div class="highlight"><pre><span></span>    <span class="n">sname</span> <span class="o">=</span> <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">sname</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__dict__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PyEval_GetRestricted</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
               <span class="s">&quot;class.__dict__ not accessible in restricted mode&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_dict</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_dict</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__bases__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_bases</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_bases</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__name__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">Py_None</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">;</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>这一段首先是检查要获取的是否为特殊属性 <code>__dict__</code>, <code>__bases__</code> 和 <code>__name__</code>，如果是则返回这个类对象的那个特殊属性。之所以作这样的检查是因为接下来就要执行 <code>class_lookup</code> 函数查找，从上面的分析可以知道， <code>class_lookup</code> 函数还会查找其父类，而这些特殊属性每个类对象都有的，所以先做检查可以防止返回错误的属性值，</p>
<div class="highlight"><pre><span></span>    <span class="n">v</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">klass</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                     <span class="s">&quot;class %.50s has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                     <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">),</span> <span class="n">sname</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>通过 <code>class_lookup</code> 函数查找这个值，如果找不到则返回 NULL，</p>
<div class="highlight"><pre><span></span>    <span class="n">f</span> <span class="o">=</span> <span class="n">TP_DESCR_GET</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>如果找到则尝试获取这个属性值对象的描述符，如果找到(实现了 <code>__get__</code> 方法)，则调用这个描述符方法，因为是类对象，所以第二个参数为 NULL。最后返回值 v 。</p>
<h4>类对象的 setattr 函数</h4>
<p>接下来的是类对象的 setattr 函数：</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">class_setattr</span><span class="p">(</span><span class="n">PyClassObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>


<p><code>class_setattr</code> 函数有三个参数，分别是类对象指针 op，属性名称 name 和属性的值 v，</p>
<div class="highlight"><pre><span></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyEval_GetRestricted</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
                   <span class="s">&quot;classes are read-only in restricted mode&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>注意到这里首先检查了此时是否处于受限制模式，如果处于受限制模式，此时类对象是只读的，函数将返回错误码 -1。受限模式下，不受信任的代码的执行将会受到限制。</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyString_Check</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;attribute name must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sname</span> <span class="o">=</span> <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</pre></div>


<p>然后是同样检查 name 参数是否为一个 PyString 对象，是则根据这个字符串对象返回一个 C 中的字符串，方便下面的比较。</p>
<p>接下来的一大段代码都是检查上面得到的这个 sname 字符串是否为特殊方法或者特殊的属性，比如 <code>__dict__</code> 或者 <code>__getattr__</code> 等，如果是则调用相关的函数 <code>set_dict</code> 等，一般来说这些特殊属性是不可以修改的，所以会返回错误提示。</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">PyDict_DelItem</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                         <span class="s">&quot;class %.50s has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                         <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">),</span> <span class="n">sname</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>参数 v 为空则将这个保存在类对象结构体 <code>cl_dict</code> 成员中的 name 属性删除掉，</p>
<div class="highlight"><pre><span></span>    <span class="k">else</span>
        <span class="k">return</span> <span class="nf">PyDict_SetItem</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">cl_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>否则，给这个属性 name 赋值 v，保存在类对象的 <code>cl_dict</code> 中。<code>PyDict_SetItem</code> 函数将会检测第一个字典参数中是否具有第二个参数 name 这个键，存在则更新其对应的值为 v，不存在则新建一个键，其值也是 v。</p>
<h4>实例对象的 getattr 函数</h4>
<p>实例对象只有一个简单地搜索属性字典 dict 的函数 <code>_PyInstance_Lookup</code>，这个函数很简单，就是里面做了一点的检查，然后就调用了 <code>PyDict_GetItem</code> 函数从实例对象的 dict 中获取这个值。</p>
<p>而实例对象的 getattr 函数则更多地调用到了<code>class_lookup</code> 函数。CPython 的源码中，关于实例对象的 getattr 和 setattr 函数灰常蛋疼，getattr 函数有三个，分别是 <code>instance_getattr</code> ，<code>instance_getattr1</code> 和 <code>instance_getattr2</code>...而 setattr 函数也有两个，分别是 <code>instance_setattr1</code> 和 <code>instance_setattr</code>。如下：</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_getattr</span><span class="p">(</span><span class="k">register</span> <span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>


<p>参数是实例对象指针 inst 和属性名称 name，</p>
<div class="highlight"><pre><span></span>    <span class="k">register</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">instance_getattr1</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</pre></div>


<p>其实在这里就调用 <code>instance_getattr1</code> 函数了，参数是一致的，如果 <code>instance_getattr1</code> 函数的返回非 NULL，则直接会返回这个结果，下面一段不会执行，</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">func</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="o">-&gt;</span><span class="n">cl_getattr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyErr_ExceptionMatches</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">PyErr_Clear</span><span class="p">();</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">PyTuple_Pack</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">PyEval_CallObject</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<p>如果 <code>isntance_getattr1</code> 函数的返回值为 NULL 并且实例对象的类的 getattr 函数存在，则调用这个类对像的 getattr 函数，参数是将实例对象指针 inst 和属性名称 name 打包成的元组。</p>
<div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>最后返回结果。</p>
<p><code>instance_getattr1</code> 函数如下：</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_getattr1</span><span class="p">(</span><span class="k">register</span> <span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
</pre></div>


<p>参数同样是 inst 和 name，</p>
<div class="highlight"><pre><span></span>    <span class="k">register</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyString_Check</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;attribute name must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">sname</span> <span class="o">=</span> <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</pre></div>


<p>例行检查参数的合法性，合法则将 name 参数转化为 C 的字符串，</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">sname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">sname</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__dict__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PyEval_GetRestricted</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
            <span class="s">&quot;instance.__dict__ not accessible in restricted mode&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__class__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">);</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>同样是检查是否为特殊的属性，主要是以 <code>__</code> 作为开头的属性，这里处理的只有 <code>__dict__</code> 和 <code>__class__</code>。如果是 <code>__dict__</code> ，在受限模式下，会抛出错误表明不可以读取，非受限模式下则返回这个实例对象的属性字典 dict。如果是 <code>__class__</code> ，也是对应地返回实例对象的类。 </p>
<div class="highlight"><pre><span></span>    <span class="n">v</span> <span class="o">=</span> <span class="n">instance_getattr2</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                     <span class="s">&quot;%.50s instance has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                     <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">),</span> <span class="n">sname</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>然后调用了 <code>instance_getattr2</code> 函数，如果其返回值为 NULL 则表示不存在这个属性，输出提示，否则返回这个结果 v。</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">instance_getattr2</span><span class="p">(</span><span class="k">register</span> <span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">;</span>
    <span class="n">PyClassObject</span> <span class="o">*</span><span class="n">klass</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">f</span><span class="p">;</span>
</pre></div>


<p>同样的， <code>instance_getattr2</code> 函数也是有两个参数 inst 和 name，</p>
<div class="highlight"><pre><span></span>    <span class="n">v</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>首先在这个实例对象的 in_dict 中查找这个属性，如果找到则直接返回其值，</p>
<div class="highlight"><pre><span></span>    <span class="n">v</span> <span class="o">=</span> <span class="n">class_lookup</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">klass</span><span class="p">);</span>
</pre></div>


<p>没有找到则去查找这个实例对象的类对象 <code>in_class</code>，通过上面对 <code>class_lookup</code> 函数的分析我们可以知道，这个查找会一直从实例对象所属的类，其类的父类，父类的父类一直搜索，直到搜索完毕。如果找到了，则返回这个属性的值对象。</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">TP_DESCR_GET</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">inst</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">));</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>


<p>在这里同样也试图获取这个实例对象对应类型的描述符方法，</p>
<div class="highlight"><pre><span></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>返回结果 v ，有值或者 NULL。</p>
<p>从对上面三个 getattr 函数的分析可以看到，其实这三个函数各有其功能，比如 <code>instance_getattr1</code> 处理的是特殊属性，而 <code>instance_getattr2</code> 则是对应普通的属性，会一直搜索到其所属的类和其类的父类等等。如果这两个函数都没有结果，则会调用其类的 getattr 函数。</p>
<p>所以这三个函数其实是有其各自的职责的，当然它们三个是可以合并起来成为一个大函数的，但是估计就是不希望看到一个大函数的出现所以才分散为三个函数，这样职责更小更分明。</p>
<h4>实例对象的 setattr 函数</h4>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">instance_setattr</span><span class="p">(</span><span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">;</span>
</pre></div>


<p><code>instance_setattr</code> 函数有三个参数，毫无疑问分别是实例对象指针 inst ，属性名称 name 和值 v，</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyString_Check</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span> <span class="s">&quot;attribute name must be a string&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">sname</span> <span class="o">=</span> <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</pre></div>


<p>同样，惯例检查 name 参数的合法性，合法则转化为 C 的字符串类型变量，</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">sname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">sname</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">PyString_Size</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sname</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">sname</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span> <span class="p">{</span>
</pre></div>


<p>判断是否为特殊属性，</p>
<div class="highlight"><pre><span></span>            <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__dict__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">PyEval_GetRestricted</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
                 <span class="s">&quot;__dict__ not accessible in restricted mode&quot;</span><span class="p">);</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                       <span class="s">&quot;__dict__ must be set to a dictionary&quot;</span><span class="p">);</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">;</span>
                <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
</pre></div>


<p>是 <code>__dict__</code> 则检查是否为受限模式，检查传入的 v 参数是否为合法的 PyDict 对象，如果是则将 v 赋值给实例对象的 <code>in_dict</code>。可以注意到，这里用了一个 tmp 变量来保存实例对象之前的 <code>in_dict</code> 变量，然后将其引用计数减一。    </p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="s">&quot;__class__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyEval_GetRestricted</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span>
    <span class="s">&quot;__class__ not accessible in restricted mode&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">PyClass_Check</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
           <span class="s">&quot;__class__ must be set to a class&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyClassObject</span> <span class="o">*</span><span class="p">)</span><span class="n">v</span><span class="p">;</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>如果是 <code>__class__</code> 和上面的操作类似。通过这一段代码，我们可以看到在非受限模式的情况下，一个实例对象的类是可以被动态修改的。</p>
<div class="highlight"><pre><span></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="o">-&gt;</span><span class="n">cl_delattr</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="o">-&gt;</span><span class="n">cl_setattr</span><span class="p">;</span>
</pre></div>


<p>如果参数 v 为 NULL，则表示要将实例对象的这个属性删除掉，试图去获取实例对象所对应的类对象的 delattr 函数。v 不为 NULL 则获取类对象的 setattr 函数，</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">func</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instance_setattr1</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</pre></div>


<p>如果没有获取到任何的函数，则将会调用 <code>instance_setattr1</code> 函数。</p>
<div class="highlight"><pre><span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">PyTuple_Pack</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">PyTuple_Pack</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">PyEval_CallObject</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
</pre></div>


<p>无论得到的是类对象的 delattr 还是 setattr 函数，这里将会调用这个函数，区别在于调用 delattr 函数参数元组只有 inst 和 name 而调用 setattr 函数参数则是多了一个参数 v。根据上面对类对象的 setattr 的分析可以知道，如果这个类有 setattr 函数，则将会调用它的 setattr 函数。</p>
<div class="highlight"><pre><span></span>    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>执行成功则返回 0。</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">instance_setattr1</span><span class="p">(</span><span class="n">PyInstanceObject</span> <span class="o">*</span><span class="n">inst</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">PyDict_DelItem</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                         <span class="s">&quot;%.50s instance has no attribute &#39;%.400s&#39;&quot;</span><span class="p">,</span>
                         <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="o">-&gt;</span><span class="n">cl_name</span><span class="p">),</span>
                         <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>如果参数 v 为空，则表示删除这个属性，所以将会调用 <code>PyDict_DelItem</code> 函数将这个属性从实例对象的 dict 字典中删除，</p>
<div class="highlight"><pre><span></span>    <span class="k">else</span>
        <span class="k">return</span> <span class="nf">PyDict_SetItem</span><span class="p">(</span><span class="n">inst</span><span class="o">-&gt;</span><span class="n">in_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>否则就直接调用 <code>PyDict_SetItem</code> 函数更新 dict 中的这个值或者添加进 dict 中。</p>
<p>从上面对这两个 setattr 函数的分析，同样可以知道，这两个函数各自有其职责。<code>instance_setattr</code> 主要是对特殊属性进行处理或者是调用其类对象的 setattr 或者 delattr 函数，而 <code>instance_setattr1</code> 函数则是对这个实例对象的 dict 进行 <code>set_item</code> 或者 <code>del_item</code> 操作。</p>
<h3>总结</h3>
<p>其实写到后面已经有点头大了，引用了一大堆源码更像是给源码注释了。但是既然已经写了，那就当给源码注释把它给写完了。</p>
<p>虽然是罗嗦了一堆，但是通过这个分析过程，对于文章开头的那几段代码的情况还是很清晰的：</p>
<ul>
<li>首先，给实例对象 t 添加一个属性 <code>ins_new_var</code> 则将会保存到 t 的 <code>__dict__</code> 中;</li>
<li>而当试图在类对象 TestCls 中取 <code>ins_new_var</code> 的时候，只会去搜索这个类对象的 dict 和其父类的 dict ，这肯定是找不到的，所以返回属性错误;</li>
<li>当给类对象 TestCls 添加一个属性 <code>new_var</code> 的时候，同样，会在 <code>__dict__</code> 中添加一个 <code>new_var</code> 对象;</li>
<li>当访问 t.new_var 的时候，在 t 的命名空间中搜索不到 <code>new_var</code> 的时候，就回去搜索其实例化自的类对象的命名空间，所以，就可以得到这个值了。</li>
</ul>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="http://blog.tonychow.me/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>